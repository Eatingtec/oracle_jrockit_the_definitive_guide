<a name="5.6" />
# 5.6 调优

在将基准测试集成到测试框架后，每当应用程序可以在可控环境下稳定运行，或因修改算法实现打了一个小版本时，就应该执行回归测试，以便可以保证将来即使修改了代码，也不会出现性能下降的情况。

执行基准测试的另一个目的是提供一个小的、自包含的沙箱（sandbox），在这个沙箱中针对应用程序的某一部分进行性能调优，以期可以达到软件项目预定的性能目标。

在某些案例中，基准测试的结果表明，应用程序某些模块需要彻底重写，以便使用执行效率更高的算法，而在另一些案例中，只需要调整JVM的参数即可满足要求。

<a name="5.6.1" />
## 5.6.1 非规范化行为（Out of the box behavior）

在之前章节中已经提到过，自适应运行时的反馈信息对JVM优化有着至关重要的作用。

理想情况下，使用了自适应运行时的系统应该是根本不需要调优的，自适应运行时会反馈反馈信息适时的调节应用程序的行为。但可惜的是，机器的推断能力还没有强大到可以和人相比的地步，尽管它在查找热点方法和膨胀/收缩锁等方面比人工操作强，但在其他一些方面就力不从心了，譬如说，如果应用程序可用的堆够大的话，根本就不需要缩放堆内存，又或者如果不关心内存碎片问题，那么就不需要执行堆整理的操作等等，自适应运行时无法推测出这些内容，需要由开发人员专门对JVM进行配置。另一方面，如果开发人员高估了自己的水平或者没有掌握足够的信息的话，就可能会做出错误的配置。

应用程序的行为应该通过专门的分析器来收集，就JRockit来说，它使用了非侵入性的行为收集器，可以以较小的性能损耗来记录应用程序的行为，为避免影响应用程序的运行，分析工作可以离线进行。

在调优应用程序之前，首先要明确应用程序的性能瓶颈在哪里，花大力气去优化非瓶颈的代码是不值得的，而且还会增加代码的复杂度。例如，通过JRockit飞行记录仪发现应用程序的性能瓶颈是网络处理能力不足，这种情况下，匆忙将10几行的代码换成百十来行的"高端算法"是很不明智的。为了避免引入不必要的复杂性，面对问题时应优先选择简便的解决方案。

在某些案例中，在做完应用程序分析后发现根本不需要对修改应用程序，从分析结果看，调整运行时参数即可解决问题。在介绍相关命令行参数之前，需要强调的一点是，调优所涉及到的很多参数和JVM的行为都是各大JVM厂商非规范性的、自定义的（out of the box，译者注，后面简称为OOTB）。就JRockit来说，每个新版本都会对这些OOTB特性进行大量优化，以便更好的满足用户对应用程序执行性能的要求，使用户可以专注于自身的业务逻辑开发。

>最后强调一下，通过命令行参数来自行配置JVM的运行行为可能会产生意料之外的结果，此外，同一款JVM的不同版本对同一命令行参数的支持可能也不尽相同，使用应多加小心。在以JRockit为例，命令行参数以`-XX`开头表明该参数的含义代可能会在不同的版本之间发生变化，使用时要注意查看相关文档的说明。

<a name="5.6.2" />
## 5.6.2 调优目标

正如在[第3章][1]中提到的，无论JVM中所运行的是何种应用程序，调优工作都是一样的，调优的基本目标大致可分为高吞吐、低延迟或近实时，其中，近实时可算作是低延迟的高级特例。

在前几章中已经介绍过这几个优化目标，本节将对其中所涉及到的一些命令行参数做简单介绍，相关内容只针对JRockit进行讲解，其他JVM实现内部原理超出本书范围，此处不再赘述。尽管不同JVM版本对同一命令行参数定义可能有所区别，但其所涉及到的基本原理和技术却是相同的。

在使用命令行参数之前，一定要先查询[JRockit文档][3]，尤其是[JRockit诊断指南][2]，明确所要使用的命令行参数的具体作用，此外可以通过JRockit Mission Control套件记录使用该参数前后应用程序的行为来加深对该参数的理解。

为了避免把篇幅搞的太大，本节中并没有提供太多的相关示例，这些内容可以在[JRockit文档][3]，尤其是[JRockit诊断指南][2]中找到。

>本节中所介绍的命令行参数均以JRockit R28版本为基准，在其他的版本中，参数的含义可能不尽相同，具体情况请查阅相关文档。

<a name="5.6.2.1" />
### 5.6.2.1 内存管理

本节将对与内存管理系统和垃圾回收器相关的命令行参数进行介绍。

<a name="5.6.2.1.1" />
#### 5.6.2.1.1 设置堆的容量

在第3章中曾经介绍过，命令行参数`-Xms`和`-Xmx`分别可以用来设置堆的初始大小的最大容量。

如果应用程序有实时性的要求，则通常会将`-Xmx`和`-Xms`的值均设置为当前系统所能支持的最大值，以避免堆在应用程序运行过程中出现伸缩的情况。

示例：

    java -Xms1024M -Xmx1024M Application    将堆的初始值和最大值均设置为1GB

<a name="5.6.2.1.2" />
#### 5.6.2.1.2 设置垃圾回收算法

Furthermore, pick a GC algorithm that makes sense for the current application.
For real-time performance targets, do not forget to specify a service level agreement,
using the  –XpauseTarget option.

For batch processing and throughput optimization,  –XgcPrio:throughput is the
way to go.

Example:  java –XgcPrio:pausetime –XpauseTarget:250ms (set up GC optimizing
for low pause times with a pause time target of maximum 250 milliseconds)









[1]:    ../chap3/3.md#3
[2]:    http://docs.oracle.com/cd/E15289_01/doc.40/e15059/toc.htm
[3]:    http://docs.oracle.com/cd/E15289_01/index.htm