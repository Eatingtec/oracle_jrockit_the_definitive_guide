<a name="5.6" />
# 5.6 调优

在将基准测试集成到测试框架后，每当应用程序可以在可控环境下稳定运行，或因修改算法实现打了一个小版本时，就应该执行回归测试，以便可以保证将来即使修改了代码，也不会出现性能下降的情况。

执行基准测试的另一个目的是提供一个小的、自包含的沙箱（sandbox），在这个沙箱中针对应用程序的某一部分进行性能调优，以期可以达到软件项目预定的性能目标。

在某些案例中，基准测试的结果表明，应用程序某些模块需要彻底重写，以便使用执行效率更高的算法，而在另一些案例中，只需要调整JVM的参数即可满足要求。

<a name="5.6.1" />
## 5.6.1 非规范化行为（Out of the box behavior）

在之前章节中已经提到过，自适应运行时的反馈信息对JVM优化有着至关重要的作用。

理想情况下，使用了自适应运行时的系统应该是根本不需要调优的，自适应运行时会反馈反馈信息适时的调节应用程序的行为。但可惜的是，机器的推断能力还没有强大到可以和人相比的地步，尽管它在查找热点方法和膨胀/收缩锁等方面比人工操作强，但在其他一些方面就力不从心了，譬如说，如果应用程序可用的堆够大的话，根本就不需要缩放堆内存，又或者如果不关心内存碎片问题，那么就不需要执行堆整理的操作等等，自适应运行时无法推测出这些内容，需要由开发人员专门对JVM进行配置。另一方面，如果开发人员高估了自己的水平或者没有掌握足够的信息的话，就可能会做出错误的配置。

应用程序的行为应该通过专门的分析器来收集，就JRockit来说，它使用了非侵入性的行为收集器，可以以较小的性能损耗来记录应用程序的行为，为避免影响应用程序的运行，分析工作可以离线进行。

在调优应用程序之前，首先要明确应用程序的性能瓶颈在哪里，花大力气去优化非瓶颈的代码是不值得的，而且还会增加代码的复杂度。例如，通过JRockit飞行记录仪发现应用程序的性能瓶颈是网络处理能力不足，这种情况下，匆忙将10几行的代码换成百十来行的"高端算法"是很不明智的。为了避免引入不必要的复杂性，面对问题时应优先选择简便的解决方案。

在某些案例中，在做完应用程序分析后发现根本不需要对修改应用程序，从分析结果看，调整运行时参数即可解决问题。在介绍相关命令行参数之前，需要强调的一点是，调优所涉及到的很多参数和JVM的行为都是各大JVM厂商非规范性的、自定义的（out of the box，译者注，后面简称为OOTB）。就JRockit来说，每个新版本都会对这些OOTB特性进行大量优化，以便更好的满足用户对应用程序执行性能的要求，使用户可以专注于自身的业务逻辑开发。

>最后强调一下，通过命令行参数来自行配置JVM的运行行为可能会产生意料之外的结果，此外，同一款JVM的不同版本对同一命令行参数的支持可能也不尽相同，使用应多加小心。在以JRockit为例，命令行参数以`-XX`开头表明该参数的含义代可能会在不同的版本之间发生变化，使用时要注意查看相关文档的说明。

<a name="5.6.2" />
## 5.6.2 调优目标

正如在[第3章][1]中提到的，无论JVM中所运行的是何种应用程序，调优工作都是一样的，调优的基本目标大致可分为高吞吐、低延迟或近实时，其中，近实时可算作是低延迟的高级特例。

在前几章中已经介绍过这几个优化目标，本节将对其中所涉及到的一些命令行参数做简单介绍，相关内容只针对JRockit进行讲解，其他JVM实现内部原理超出本书范围，此处不再赘述。尽管不同JVM版本对同一命令行参数定义可能有所区别，但其所涉及到的基本原理和技术却是相同的。

在使用命令行参数之前，一定要先查询[JRockit文档][3]，尤其是[JRockit诊断指南][2]，明确所要使用的命令行参数的具体作用，此外可以通过JRockit Mission Control套件记录使用该参数前后应用程序的行为来加深对该参数的理解。

为了避免把篇幅搞的太大，本节中并没有提供太多的相关示例，这些内容可以在[JRockit文档][3]，尤其是[JRockit诊断指南][2]中找到。

>本节中所介绍的命令行参数均以JRockit R28版本为基准，在其他的版本中，参数的含义可能不尽相同，具体情况请查阅相关文档。

<a name="5.6.2.1" />
### 5.6.2.1 内存管理

本节将对与内存管理系统和垃圾回收器相关的命令行参数进行介绍。

<a name="5.6.2.1.1" />
#### 5.6.2.1.1 设置堆的容量

在第3章中曾经介绍过，命令行参数`-Xms`和`-Xmx`分别可以用来设置堆的初始大小的最大容量。

如果应用程序有实时性的要求，则通常会将`-Xmx`和`-Xms`的值均设置为当前系统所能支持的最大值，以避免堆在应用程序运行过程中出现伸缩的情况。

示例：

    java -Xms1024M -Xmx1024M Application    
    将堆的初始值和最大值均设置为1GB

<a name="5.6.2.1.2" />
#### 5.6.2.1.2 设置垃圾回收算法

针对应用程序的特点选择合适的垃圾回收算法是很重要的。如果对应用程序的响应时间有要求的话，那么不要忘了使用`-XpauseTarget`参数来设置相应的服务级别。

如果应用程序执行的是批处理作业，优化目标一般是最大化吞吐量，那么就可以设置参数`–XgcPrio:throughput`.

示例：

    java –XgcPrio:pausetime -XpauseTarget:250ms    
    将JVM的优化目标设置为低延迟，并设定期望的最大暂停时间为250ms

<a name="5.6.2.1.3" />
#### 5.6.2.1.3 内存整理

随着应用程序的不断运行，堆中的内存会呈现出碎片化的趋势。早期的应用程序对碎片化没什么办法，只能重启应用程序，但这种方式会加大应用程序的整体延迟，浪费CPU资源。从已有的经验看，对堆的一部分空间进行整理可以有效应对碎片化的问题。JRockit JVM中使用的就是这种策略，并在自适应运行时的帮助下，自行对垃圾回收的行为进行调整。

垃圾回收的一大瓶颈就是内存整理，因为这一步操作很难以完全并发的方式执行。如果能够获得有关内存碎片和对象大小相关的信息（例如可以通过JRockit飞行记录仪得到），那么在做调优的时候就能更具针对性。就JRockit来说，可以使用命令行参数`-XXcompaction`及其相关参数来指定与内存整理相关的行为。

JRockit中内存整理的算法是将堆划分成多个同样大小的分区，内存整理以分区为单位进行，执行时可能需要暂停应用程序。默认配置下，会使用4096个分区，实际应用时如果执行内存整理的速度跟不上内存碎片化的速度，则需要减少分区的数量；如果内存整理是破坏性的，则可以增大分区的数量。典型情况下，如果优化策略不是针对最大化吞吐量的话，垃圾回收器所整理出的内存空间的大小很大程度上取决于执行内存整理的频率。命令行参数`–XXcompaction:heapParts`可以用来设定所使用的分区数量。

在JRockit中，内存整理分为 **内部整理（internal compaction）**和**外部整理（external compaction）**两类，其中外部整理也被称为。内部整理的操作只集中于某个内存分区内部，将对象移动到分区头部，而不会将对象移动到其他分区。外部整理会同时作用于多个分区，并尽量将对象移动到整个堆的头部，从而降低整个堆的碎片化程度。因此，相比于内部整理，外部整理的并发性较低，而且会有一个较长时间的、STW式的操作过程。

内存整理是以滑动窗口的形式完成对整个堆的整理。目前JRockit中会交错使用内部整理和外部整理，如果本次垃圾回收使用的是内部整理，则下一次会使用外部整理。

命令行参数`-XXcompcation:internalPercentage`和`-XXcompcation:externalPercentage`分别来用设置执行内存整理时会对多少个分区执行整理操作。

>译者注：虽然参数名表明设置的是比例，但实际上设置的是分区数量，参见文档[http://docs.oracle.com/cd/E15289_01/doc.40/e15062/optionxx.htm][4]的说明。

如果已知应用程序的对象分配策略，并且期望降低系统延迟，那么可以使用命令行参数`–XXcompaction:enable=false`来关闭所有的内存整理操作。在启用这个参数之前，应该先通过JRockit Mission Control来确认是否有必要处理碎片化问题。关闭内存整理可以大幅减少内存管理中对暂停Java应用程序的需求，但对于那些内存较大、运行时间较长的应用程序来说，关闭内存整理很有可能最终会使应用程序因发生`OutOfMemoryError`错误而崩溃。

另一方面，如果应用程序对延迟没什么要求，即使应用程序有较长的暂停时间也不在乎，而是只关心吞吐量的话，那么可以指定`–XXcompaction:full`参数，该参数会强制垃圾回收器在每次执行垃圾回收时对整个堆做内存整理，这样可以尽可能降低内存中碎片化程度。在某些案例中，对整个堆执行内存整理的速度很慢，导致应用程序暂停时间过长，结果反而使吞吐量下降，因此使用时要仔细分析应用程序的行为特点。

>在JRockit Mission Control中，有时也把对整个堆做内存整理的操作称为 **异常整理（exceptional compaction）**。

对于那些追求低延迟的应用程序来说，如果内存整理的时间过长，则应该终止当前的内存整理操作。在默认的吞吐量优先垃圾回收器中，中断内存整理默认是被禁用的，可以通过设置命令行参数`–XXcompaction:abortable`来强制启用。

There are several additional ways to tune compaction that are beyond the scope
of this chapter. Please refer to the JRockit Diagnostics Guide for in-depth guidance.
Finally, note that playing around with compaction parameters when tuning for real-
time, might result in larger performance deviations and in less deterministic pause
times. Some of the ways to tune compaction are:

还有一些其他参数可用来对内存整理的操作进行设置，这些内容超出本书范围，此处不再赘述，相关内容请查阅[JRockit诊断指南][2]。最后强调一下，当为了提升应用程序的实时性而调整与内存整理相关的参数时，有可能会使应用程序的整体性能有较大偏差，降低对应用程序暂停时间的准确性。

示例：

    java –XXcompaction:enable=false <application>    
    禁用内存整理
    
    java –XXcompaction:full <application>            
    对整个堆执行内存整理，最大化吞吐量
    
    java –XXcompaction:internalPercentage=1.5, externalPercentage=2,heapParts=512 <application>
    将堆划分为512个分区，每次内部整理会处理1.5个分区，每次外部整理会处理2个分区
    
    java –XgcPrio:throughput –XXcompaction:abortable=true <application>  
    以最大化吞吐量为主要优化目标，同时允许中断内存整理操作以兼顾对低延迟的需求








[1]:    ../chap3/3.md#3
[2]:    http://docs.oracle.com/cd/E15289_01/doc.40/e15059/toc.htm
[3]:    http://docs.oracle.com/cd/E15289_01/index.htm
[4]:    http://docs.oracle.com/cd/E15289_01/doc.40/e15062/optionxx.htm