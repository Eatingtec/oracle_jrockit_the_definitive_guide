<a name="5.3" />
# 5.3 确定测试目标

基准测试的测试目标取决于目标应用程序的具体类型，需要依实际情况来确定。

<a name="5.3.1" />
## 5.3.1 吞吐量

测试以吞吐量为优化目标的应用程序相对来说会容易一些，测试时需要注意的是在给定的周期内尽可能多的执行应用程序的具体操作。作为回归测试使用时，基准测试需要验证，在基线硬件（baselined hardware）上，应用程序是否仍旧可以在`y`秒内执行`x`个操作。如果满足条件的话，就可以继续测试是否可以维持住吞吐量。

正如在[3.3.5.1节][1]中提到的，吞吐量本身通常不是什么大问题（除非是批处理任务和离线分析场景下），写一个用来测试吞吐量的基准测试也不是什么难事，通常可以直接从主应用程序中直接抽取出来，根本无需使用什么技巧。

<a name="5.3.2" />
## 5.3.2 兼顾吞吐量、响应时间和延迟

通常可以对前面提到的以吞吐量为目标的基准测试进行改进，使其可用于测量在给定的响应时间范围内的吞吐量。

如果为基准测限制了固定的响应时间，那么也就加上了延迟这个限制因素。该基准测试可用来验证应用程序在预设的响应时间范围内，是否可以稳定运行于不同的工作负载下。

>JRockit质量保证团队内部使用基准测试套件中包含了很多附加了响应时间要求的吞吐量基准测试工具。这些工具用来验证准确式垃圾回收器在不同的工作负载下是否可以满足任务需要。

对大多数用户来说，低延迟通常比高吞吐更重要，至少在C/S架构的程序中是这样的，而编写以低延迟为目标的基准测试会更具挑战。

>一般情况下，简单的Web应用程序的响应时间会在1秒左右，而在金融行业，普遍要求应用程序暂停时间要小于10毫秒。

类似的，在电信行业，通常要求应用程序的暂停时间要小于50毫秒。为了满足这些要求，用户和JVM厂商就需要针对低延迟要求做细致的基准测试。

<a name="5.3.3" />
## 5.3.3 伸缩性

针对伸缩性进行的基准测试主要是测量相关资源的利用率。良好的伸缩性意味着随着工作负载的上升，应用程序依然运行稳定，标签良好。如果应用程序的伸缩性不好，说明其无法充分利用硬件资源，结果往往会导致吞吐量下降。理想情况下，线性增长的工作负载最多只会使应用程序的性能和服务质量现行下降。

The following figure illustrates a nice example of near linear scalability on a
per-core basis. It shows the performance in ops per second for an older version
of the JRockit JVM running the well-known SPECjbb2005 benchmark. SPECjbb2005
is a multithreaded benchmark that gradually increases load on a transaction
processing framework.

下图展示了






[1]:    ../chap3/3.3.md#3.3.5.1