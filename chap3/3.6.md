# 3.6 内存操作相关的API

This section covers some of the unique constructs of the Java language, related to memory management.

Dreaming of `delete` or `free` operators for Java or trying to explicitly control the garbage collection behavior in a JVM by, for example, hanging on to objects longer than their natural lifespans is a sure way of shooting yourself in the foot. There are, however, some mechanisms in the Java language that make it possible to help the GC by giving it "hints". Some of the available mechanisms are good and some are bad. Some should be used with caution to avoid unwanted side effects.

<a name="3.6.1" />
## 3.6.1 Finalizers

In Java, since Java 1.0, every object contains a method called `finalize` that may be freely overridden by any implementer. The contract is that the `finalize` method is called just before the object in question is about to be garbage collected. This might seem like a good idea, making it possible to do cleanups before the object goes away, such as closing any open file handles that the object may hold on to.

However, since a `finalize` method can contain arbitrary code, there are several potentially bad scenarios to consider as well, for example, the case that a finalizer **resurrects** the object, or clones a new object from the dying one, in effect preventing an object from being garbage collected. In addition, placing code that releases limited resources, such as file handles, in a finalizer may cause resource starvation. This is because there is never a predictable point in time where finalizers are guaranteed to be run. System resources should always be released explicitly in a situation where the programmer has control.

Furthermore, finalizers can also be called at any time in any thread, no matter which locks the thread is holding. This is extremely bad and can lead to all kinds of unintended deadlock situations and violations of mutual exclusion semantics.

It is not just the authors' opinion, but that of the Java community in general, that finalizers are a bad design choice and that their use should be avoided at any cost.

<a name="3.6.2" />
## 3.6.2 References

When programming Java, one might think that there is only one kind of object reference. An object is either live or unreachable, eventually leading to it being garbage collected and removed from the system. There are, however, several kinds of references in Java, which may be thought of as references with varying degrees of liveness. We refer to the normal references or standard object references, as **strong references**.

The package `java.lang.ref` contains several classes that wrap Java objects and thereby provide a classification for the object's reference type. The different reference classes all extend `java.lang.ref.Reference`. All `Reference` objects in Java have a `get` method that will return the actual object being referenced or `null` if that particular object isn't reachable, i.e. if the object has been garbage collected.

Java also provides the class `java.lang.ref.ReferenceQueue`, where objects that change reachability or scope are enqueued, for example when the object a `Reference points` to gets garbage collected. A `Reference` object can be bound to a `java.lang.ref.ReferenceQueue` at instantiation. By polling an instance of the `ReferenceQueue`, a small amount of insight into what the memory management system is doing can be gained programmatically.

There are four main types of references in Java—**strong, weak, soft and phantom references**.

<a nam3="3.6.2.1" />
### 3.6.2.1 弱引用

A **weak reference** that points to an object isn't strong enough to force that object to remain in memory. The java.lang.ref.WeakReference class is in effect a wrapper around a strong reference, tagging it as weak.

    WeakReference weak = new WeakReference(object);

In the example, to get the actual object the reference points to, use `weak.get()`. As `object` may be garbage collected at any time, this call returns null when `object` is no longer in memory.

A typical application for weak references is the `java.util.WeakHashMap` class, which gets rid of an entry if its key is no longer referenced. This is ideal for caches. Using weak references in the memory leak prone `HashMap` cache example, introduced in the first section of this chapter, would prevent leaks caused by forgotten objects left in the hash table. It would also have the added benefit of not requiring that hash table contents are cleared out in order for it to ever be garbage collected. Weak references can provide an intrinsic protection against memory leaks.

<a name="3.6.2.2" />
### 3.6.2.2 软引用

A **soft reference** is a weak reference that the garbage collector is more reluctant to throw away. Typically, the garbage collector tries to keep them around as long as possible, but they are the first to go if memory is running low.

How much stronger a soft reference should be, than a weak reference, is left to the JVM implementation. In theory, a soft reference may behave exactly like a weak reference and not violate the Java semantics.

<a name="3.6.2.3" />
### 3.6.2.3 幽灵引用

**Phantom references** are the preferred way of implementing finalization. They are designed to supersede the use of finalizers that, as we have seen, are deeply flawed. Phantom references wrap ordinary objects similar to weak and soft references, but their `get` method always returns `null`.

Phantom references are accessed through the `java.lang.ref.ReferenceQueue` class mentioned earlier, by polling an instance to which the phantom references one is interested in are bound. Polling the reference queue at regular intervals (or doing a blocking `remove`) reveals if a new phantom reference is available for garbage collection. If this is the case, as the `get` method of phantom references always returns `null`, there is no possible way to get hold of a handle to the object in question and resurrect it. This avoids the problems with finalizers and provides all the benefits of a similar mechanism.

Here is a code example that prints the number of finalized `TestObjects` in the system using finalizers:

    /**
     * Prints the number of finalized objects
     */
    public class Finalize {
        static class TestObject {
            static int nObjectsFinalized = 0;
            
            protected void finalize() throws Throwable {
                System.err.println(++nObjectsFinalized);
            }
            
        }

        public static void main(String[] args) {
            for (;;) {
                TestObject o = new TestObject();
                doStuff(o);
                o = null;    //clear any remaining refs to "o"
                System.gc(); //try to force gc
            }
        }
    }

The equivalent approach with `PhantomReferences` in a `ReferenceQueue` might look something like this:

    /**
    * Prints the number of finalized objects using PhantomReferences
    */
    import java.lang.ref.*;
    public class Finalize {
        static class TestObject {
            static int nObjectsFinalized = 0;
        }
        
        static ReferenceQueue<TestObject> q = new ReferenceQueue<TestObject>();

        public static void main(String[] args) {
            Thread finalizerThread = new Thread() {
                public void run() {
                    for (;;) {
                        try {
                            //block until PhantomReference is available
                            Reference ref = q.remove();
                            System.err.println(++TestObject.nObjectsFinalized);
                        } catch (InterruptedException e) {
                        }
                    }
                }
            };
            finalizerThread.start();
            for (;;) {
                TestObject o = new TestObject();
                PhantomReference<TestObject> pr = new PhantomReference<TestObject>(o, q);
                doStuff(o);
                o = null; //clear any remaining refs to "o"
                System.gc(); //try to force GC
            }
        }
    }

<a name="3.6.3" />
## 3.6.3 Differences in JVM behavior

The most important thing to remember is that all of the above language constructs merely provide **hints** to the GC. The Java language, by design, gives no exact control over the memory system. It is a bad practice to assume, for example, that just because soft references are alive in a cache for a certain amount of time in one VM vendor's implementation, the same will be true for another vendor's implementation too.

Another example, which recurs quite frequently among customers, is misuse of the **System.gc** method. The **System.gc** method is only defined as a hint to the runtime that "now will be a good time to garbage collect". In some VMs this hint is taken almost all the time, leading to extensive GCs and the possible freeing of massive amounts of memory. In other VMs it is ignored most of the time.

In the authors' old line of work as performance consultants, we have time and time again seen this function abused. More than once, the simple removal of a couple of calls to **System.gc** has led to immense speedups for quite a few customer applications. This is the story behind the JRockit `–XX:AllowSystemGC=false` flag that basically just tells JRockit to ignore all `System.gc` calls.

