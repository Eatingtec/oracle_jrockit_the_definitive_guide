# 3.9 小结

This chapter covered automatic memory management in detail, concentrating on adaptive memory management, where feedback from the runtime system is continuously used to optimize GC performance.

We explained the mark and sweep as well as the stop and copy strategies for garbage collection and discussed how more advanced variants of these can work in a modern runtime, especially JRockit. We discussed how to implement fast scalable GC on all levels from software to hardware.

Every GC needs to stop the world at some point, for example when sweeping or compacting. Stopping the world introduces latencies. The main lesson is that we can optimize either for throughput or for low latencies, one at the cost of the other.

We introduced the product JRockit Real Time, that provides a degree of determinism and pause time targets for the JVM. JRockit Real Time can massively improve response times and decrease their deviation for most applications without the need to modify the applications.

Some of the constructs available in the Java language that can help control garbage collection and memory management were introduced, followed by a section on false optimizations. It is dangerous to believe that complete deterministic control can be exerted over as non-deterministic a system as a garbage collector.

Finally, the most common command-line options used to control memory management in JRockit were explained.

Now code generation and memory management in an adaptive runtime environment have been introduced. In the next chapter, we will cover the final fundamental building block that makes up a Java runtime—threads and synchronization.
