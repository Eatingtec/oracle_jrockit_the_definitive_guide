# 3.8 Controlling JRockit memory management

This section covers the most fundamental command-line switches that control garbage collection in JRockit. For more advanced manipulation of the memory system, for example tuning compaction, please refer to [Chapter 5, Benchmarking and Tuning][1].

<a name="3.8.1" />
## 3.8.1 Basic switches

Following are the most fundamental command-line switches for interacting with the JRockit memory system.

<a name="3.8.1.1" />
### 3.8.1.1 Outputting GC data

Running JRockit with `–Xverbose:gc` will, similar to `–Xverbose:codegen`, output plenty of verbose information on what the JVM memory management system is doing. This information includes garbage collections, where they take place (nurseries or old space), changes of GC strategy, and the time a particular garbage collection takes.

`-Xverbose:gc` (or `-Xverbose:memory`) is, except for JRockit Mission Control, the main information provider when it comes to studying garbage collector behavior for an application.

Here is an example of the output generated by `–Xverbose:gc`:

    hastur:material marcus$ java –Xverbose:gc GarbageDemo
    [INFO ][memory ] GC mode: Garbage collection optimized for throughput, strategy: Generational Parallel Mark & Sweep.
    [INFO ][memory ] Heap size: 65536KB, maximal heap size: 382140KB, nursery size: 32768KB.
    [INFO ][memory ] [YC#1] 1.028-1.077: YC 33232KB->16133KB (65536KB), 0.049 s, sum of pauses 48.474 ms, longest pause 48.474 ms.
    [INFO ][memory ] [YC#2] 1.195-1.272: YC 41091KB->34565KB (65536KB), 0.077 s, sum of pauses 76.850 ms, longest pause 76.850 ms.
    [INFO ][memory ] [YC#3] 1.857-1.902: YC 59587KB->65536KB (65536KB), 0.045 s, sum of pauses 45.122 ms, longest pause 45.122 ms.
    [INFO ][memory ] [OC#1] 1.902-1.912: OC 65536KB->15561KB (78644KB), 0.010 s, sum of pauses 9.078 ms, longest pause 9.078 ms.
    [INFO ][memory ] [YC#4] 2.073-2.117: YC 48711KB->39530KB (78644KB), 0.044 s, sum of pauses 44.435 ms, longest pause 44.435 ms.

Typically, the log shows things such as garbage collection strategy changes and heap size adjustments, as well as when a garbage collection take place and for how long.

OC or YC means `Old Collection` or `Young Collection (nursery)`, followed by the sequence number of the particular collection. Sequence numbers start at 1.

After the OC and YC identifier comes the time span in seconds, since the start of the JVM, that was spent in this particular GC.

Then JRockit reports how much live data the particular heap region that was collected contained before and after the GC, the total size of the region, and the time that particular garbage collection took. We can see that the GC chooses to gradually grow the heap in this particular example.

Finally, the sum of pauses, that is for how long the world was stopped during the last garbage collection, is reported along with the longest individual pause. In the previous example, we can infer that as these values are the same, we are dealing with complete stop-the-world-collections, i.e. parallel GC. They each consist of one large pause.

For advanced users, as has been covered, each garbage collection consists of several phases, and if you want more granularity on them, a flag called –Xverbose:gcpause will provide it. It should be noted, however, that JRockit Mission Control with its graphic illustration of garbage collection behavior probably provides more insight into application behavior.

<a name="3.8.1.2" />
### 3.8.1.2 Set initial and maximum heap size

The `–Xms` and `–Xmx` flags are standard and variants are available in all JVMs. They specify initial and maximum heap size to be allocated to the JVM. If no arguments are given, the heap will grow and shrink heuristically during runtime. Consider the following example:

    java –Xms1024M –Xmx2048M <application>

The code shown in the previous example will force the initial heap size to 1 GB and prevent it from ever growing above 2 GB. If enough heap to accommodate the demands isn't available, an `OutOfMemoryError` will be thrown.

<a name="3.8.1.3">
### 3.8.1.3 Controlling what to optimize for

Unless you really know what you are doing, the `–XgcPrio` flag is the preferred way to tell JRockit what garbage collection strategies to run. Instead of fixing a GC strategy, JRockit will heuristically determine what is best for the application, depending on what the user thinks is important and change strategies at runtime when appropriate.

* `–XgcPrio:throughput`: This optimizes for throughput, not caring about pause times
* `–XgcPrio:pausetime`: This optimizes for low latency
* `-XgcPrio:deterministic`: This activates the JRockit Real Time functionality, striving for extremely short pauses at the cost of some additional runtime overhead

The maximum pause time target for the GC (not applicable for `–XgcPrio:throughput`) can be set with the flag `–XpauseTarget`. Depending on the amount of live data on the heap and system configuration, JRockit may or may not be able to keep up. Experimenting with different pause time targets for a particular application is encouraged.

Following is command-line example for enabling deterministic GC (JRockit Real Time) with an upper pause time target of five milliseconds:

    java –XgcPrio:deterministic –XpauseTarget:5ms <application>

<a name="3.8.1.4" />
### 3.8.1.4 指定GC策略

For even further control over GC behavior, a more fine grained garbage collection strategy can be set from the command line using the `–Xgc` flag. This fixes a garbage collection strategy for the JVM and prevents it from being changed at runtime. The strategy can be made more fine grained than with one of the three `-XgcPrio` choices. Again, we use the terms concurrent and parallel to describe if we are optimizing for low latencies or throughput. The possible options are `–Xgc:singlecon` (single generational concurrent), `-Xgc:gencon` (generational concurrent), `-Xgc:singlepar` (single generational parallel) and `–Xgc:genpar` (generational parallel). "Generational", as opposed to "single generational", means that a nursery is used.

<a name="3.8.2" />
## 3.8.2 压缩引用

As already mentioned, given a maximum heap size smaller than 64 GB, JRockit will use some form of compressed references by default. But the usage of compressed references can also be explicitly controlled with the `–XXcompressedRefs` flag. The flag takes two arguments—whether compressed references should be enabled at all and in that case the maximum size of the heap that they should support.

The following command-line example disables compressed references, and forces JRockit to use native size pointers for all objects:

    java –XXcompressedRefs:enable=false <application>

This following command-line example enables compressed references that can support up to 64-GB heaps:

    java –XXcompressedRefs:enable=true,size=64GB <application>

<a name="3.8.3" />
## 3.8.3 高级选项

It should be noted that playing around too much with JVM switches doesn't necessarily lead to increased performance and might interfere with more optimal runtime behavior.

If memory performance is believed to be an application bottleneck, it is recommended to use the JRockit Mission Control suite for instrumentation. Chapters in the second part of this book will explain how to do a runtime recording with JRockit and how to analyze it. Collecting as much information as possible about an application before starting to modify non-standard parameters is strongly recommended.

Almost any aspect of the garbage collector can be tuned from the command line —everything from the size of the thread local buffers used for allocation to
the strategies used for heap compaction.

Some less fundamental switches that control memory management are covered in Chapter 5. Please study the JRockit documentation for a more in-depth description of all memory management options.




[1]:    ../chap5/5.md
