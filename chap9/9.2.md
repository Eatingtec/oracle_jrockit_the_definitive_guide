<a name="9.2" />
# 9.2 在JRockit Mission Control中使用JFR

在JRockit Mission Control客户端中可以很方便的控制事件记录的生命周期，推荐使用。

在JRockit Mission Control中开启JFR事件记录很简单，在 **JVM浏览器**右键点击目标JVM，在弹出的菜单中点击" **Start Flight Recording....**"即可。

![Figure 9-2][1]

以JRockit Mission Control 4.0版本为例，在点击" **Start Flight Recording....**"菜单之后，会：

1. 弹出 **Start Flight Recording**对话框
2. 进入 **Flight Recorder Control**视图

**Flight Recorder Control**视图实在JRockit Mission Control 4.0版本中新引入的，用于展示当前可用的JVM连接中都有哪些事件记录，并对事件记录进行控制。在该视图中可以方便的查看当前有哪些正在进行的事件记录。例如在下面的截图里，可以从Flight Recorder Control视图中看出当前已经有一个事件记录正在运行：

![Figure 9-3][2]

从上面的截图中可以看出，与JRA类似，在该对话框中，可以选择一些系统内置的模板，也可以自己创建新的模板。这些模板不同于服务器端模板，可用于图形界面，并且解析过程也有所区别。

默认的客户端模板包括：

* **普通概要分析（Default Profiling）**: 以较低的执行开销执行一些通用分析的模板。
* **带有锁定的概要分析（Profiling With Locks）**: 与 **普通概要分析**相同，并额外启用了锁分析。使用该模板时，需要在启动JVM时，添加命令行参数 `-XX:+UseLockProfiling`，不过使用该命令行参数会带来一些性能损耗。
* **带有异常错误的概要分析（Profiling with Exceptions）**: 与 **普通概要分析**相同，并且启用了异常分析。对于大多数应用程序来说，使用该模板的执行开销与使用 **普通概要分析**模板没什么区别，但是对于某些会经常抛异常的应用程序来说，这个执行开销就很可观了。
* **实时（Real-Time）**: 该模板更关注与垃圾回收相关的事件，而对其他资源的饥饿事件则不予理会。

Worth noting is that both the default client-side and server-side templates omit 
exception events by default, as it is difficult to estimate their performance impact 
on a pathological application. To include exception profiling, select the built-in 
Profiling with Exceptionstemplate. Exception profiling will be further discussed 
later in this chapter.

Once a suitable template is selected, a destination file must be specified, and an 
appropriate name chosen. Some event producers, such as the ones from the WebLogic 
Diagnostics Framework, have their own recordings running. In a large system, there 
can be quite a few recordings running in parallel. Naming the recording properly will 
make it easier to find it later.

>Not only the JVM can record events in the Flight Recorder. There 
are already event producers for the Oracle WebLogic Diagnostics 
Framework(WLDF) and theOracle Dynamic Monitoring System
(DMS). We expect more Oracle products to provide producers in 
the future, such as JRockit Virtual Edition.

It is possible to perform either a time-limited recording or a continuous one. For a 
time-limited recording, a duration must be chosen. In order to limit the resource 
usage of continuous recordings, it is possible to limit the amount of data to store, 
either by time, size, or both.

Once the recording wizard is filled out, clicking on Continuewill start the recording.

![Figure 9-4][3]

The Flight Recorder Controlview is updated to show the newly started recording. 
For time-limited recordings, the remaining time until the recording is done is shown 
and periodically updated. Continuous recordings show an infinity (∞) sign instead of 
the remaining time.

Note that there is a table settings action (  ) in the toolbar of the Flight Recorder 
control view. The table can be configured to show more information, if needed.

For a time-limited recording, the recording will be downloaded automatically once it 
is complete.

![Figure 9-5][4]

As can be seen in the previous screenshot, recordings are left on the server by default 
when completed, even after they have been downloaded. In the screenshot, My 
Recordinghas just been downloaded. It is also displayed as being finished (  ) in 
the Flight Recorder Controlview, with no time remaining. Such finished recordings 
can be removed by right clicking on the recording in the Flight Recorder Control
view and then clicking on Close.

As mentioned, it is possible to see the recording activities of more than one JVM at a 
time in the Flight Recorder Controlview. To add a connection to monitor, simply right 
click on the connection in the JVM Browserand then click on Show Recordings. The 
following screenshot shows the recordings for three different JVMs at once:

![Figure 9-6][5]

To use the control view to dump data from an ongoing recording, simply right click 
on it and select Dump....This brings up the Dump Recordingdialog, as shown in 
the following screenshot:

![Figure 9-7][6]

There are three different ways to select what part of the recording to dump:

•	 Whole recording: Dumps all available data.
•	 Last part of recording: Dumps the last data in the recording, given a 
specified period of time. Note that it is possible to get more data than was 
specified, as only whole data chunks will be dumped.
•	 Interval of recording: Dumps recording data for a specified interval of 
time. Note that the time is specified in server time. If the client is running in 
Stockholm and the server in Tokyo, make sure you specify the correct time. 
If there is no data within the specified time, an error message is displayed.

Again, what is actually dumped may be more than you were asking for. 

The data is dumped in whole data chunks of a fixed size. Each chunk of data 
contains a constant pool that the events in the chunk use to resolve the data. For 
instance, there is a pool containing the stack traces for the events. When an event 
contains a stack trace, the event will refer to the stack trace by index in the pool. This 
way, the format can be streamed and used on a per-chunk basis, each chunk being 
self-contained






[1]:    ../images/9-2.jpg
[1]:    ../images/9-3.jpg