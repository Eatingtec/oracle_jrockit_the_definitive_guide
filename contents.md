#目录

* [1 起步][1]
    * [1.1 获得JRockit JVM][2]
    * [1.2 将应用程序迁移到JRockit][3]
        * [1.2.1 命令行选项][4]
            * [1.2.1.1 系统属性][5]
            * [1.2.1.2 标准命令行选项][6]
            * [1.2.1.3 非标准命令行选项][7]
        * [1.2.2 行为差异][8]
    * [1.3 JRockit版本号的命名规则][9]
    * [1.4 获取帮助][10]
    * [1.5 小结][11]
* [2 自适应代码生成][12]
    * [2.1 平台无关性][13]
    * [2.2 Java虚拟机][14]
        * [2.2.1 基于栈的虚拟机][15]
        * [2.2.2 字节码格式][16]
            * [2.2.2.1 操作与操作数][17]
            * [2.2.2.2 常量池][18]
    * [2.3 代码生成策略][19]
        * [2.3.1 纯解释执行][20]
        * [2.3.2 静态编译][21]
        * [2.3.3 完全JIT编译][22]
        * [2.3.4 混合模式][23]
    * [2.4 自适应代码生成][24]
        * [2.4.1 判断热方法][25]
            * [2.4.1.1 调用计数器][26]
            * [2.4.1.2 基于软件的线程采样][27]
            * [2.4.1.3 硬件采样][28]
        * [2.4.2 优化动态程序][29]
    * [2.5 深入JIT编译器][30]
        * [2.5.1 处理字节码][31]
            * [2.5.1.1 字节码混淆][32]
        * [2.5.2 字节码“优化器”][33]
            * [2.5.2.1 抽象语法树][34]
        * [2.5.3 优化字节码][35]
    * [2.6 代码流水线][36]
        * [2.6.1 为什么JRockit没有字节码解释器][37]
        * [2.6.2 启动][38]
        * [2.6.3 运行时代码生成][39]
            * [2.6.3.1 Trampolines][40]
            * [2.6.3.2 代码生成请求][41]
            * [2.6.3.3 代码优化请求][42]
            * [2.6.3.4 栈上替换][43]
            * [2.6.3.5 簿记][44]
        * [2.6.4 代码生成概述][45]
            * [2.6.4.1 代码的中间表示][46]
            * [2.6.4.2 JIT编译][47]
            * [2.6.4.3 代码优化][48]
    * [2.7 控制代码生成][49]
        * [2.7.1 命令行选项与指导文件][50]
            * [2.7.1.1 命令行选项][51]
            * [2.7.1.2 指导文件][52]
    * [2.8 小结][53]
* [3 自适应内存管理][54]
    * [3.1 自动内存管理相关概念][55]
        * [3.1.1 自适应内存管理][56]
        * [3.1.2 自动内存管理的优点][57]
        * [3.1.3 自动内存管理的缺点][58]
    * [3.2 堆管理基础][59]
        * [3.2.1 对象的分配于释放][60]
        * [3.2.2 碎片与整理][61]
    * [3.3 垃圾回收算法][62]
        * [3.3.1 引用计数][63]
        * [3.3.2 引用跟踪][64]
            * [3.3.2.1 标记-清理][65]
            * [3.3.2.2 暂停-拷贝][66]
        * [3.3.3 STW(stop-the-world)][67]
            * [3.3.3.1 保守式 vs. 准确式][68]
            * [3.3.3.2 livemap][69]
        * [3.3.4 分代垃圾回收][70]
            * [3.3.4.1 多个新生代的内存排布][71]
            * [3.3.4.2 写屏障][72]
        * [3.3.5 吞吐量 vs. 延迟][73]
            * [3.3.5.1 优化吞吐量][74]
            * [3.3.5.2 优化延迟][75]
        * [3.3.6 JRockit中的垃圾回收][76]
            * [3.3.6.1 老年代垃圾回收][77]
            * [3.3.6.2 新生代垃圾回收][78]
            * [3.3.6.3 永生代垃圾回收][79]
        * [3.3.6.4 内存整理][80]
    * [3.4 性能与伸缩性][81]
        * [3.4.1 线程局部分配][82]
        * [3.4.2 更大的堆内存][83]
            * [3.4.2.1 32位架构下的4GB内存限制][84]
            * [3.4.2.2 64位架构][85]
        * [3.4.3 缓存友好性][86]
            * [3.4.3.1 预抓取][87]
            * [3.4.3.2 数据存放][88]
        * [3.4.4 NUMA][89]
        * [3.4.5 大内存页（Large pages）][90]
        * [3.4.6 自适应（Adaptability）][91]
    * [3.5 近实时垃圾回收][92]
        * [3.5.1 软实时与硬实时][93]
        * [3.5.2 JRockit Real Time][94]
            * [3.5.2.1 软实时有效么？][95]
            * [3.5.2.2 工作原理][96]
    * [3.6 内存操作相关的API][97]
        * [3.6.1 析构函数][98]
        * [3.6.2 Java中的引用][99]
            * [3.6.2.1 弱引用][100]
            * [3.6.2.2 软引用][101]
            * [3.6.2.3 虚引用][102]
        * [3.6.3 JVM的行为差异][103]
    * [3.7 陷阱与伪优化][104]
        * [3.7.1 Java不是C++][105]
    * [3.8 JRockit中的内存管理][106]
        * [3.8.1 基本参数][107]
           * [3.8.1.1 打印垃圾回收日志][108]
           * [3.8.1.2 设置堆的初始值和最大值][109]
           * [3.8.1.3 设置垃圾回收器的执行目标][110]
           * [3.8.1.4 指定垃圾回收策略][111]
        * [3.8.2 压缩引用][112]
        * [3.8.3 高级选项][113]
    * [3.9 小结][114]





[1]:    ./chap1/1.md                      "1 起步"
[2]:    ./chap1/1.1.md                    "1.1 获得JRockit JVM"
[3]:    ./chap1/1.2.md                    "1.2 将应用程序迁移到JRockit"
[4]:    ./chap1/1.2.md#1.2.1              "1.2.1 命令行选项"
[5]:    ./chap1/1.2.md#1.2.1.1            "1.2.1.1 系统属性"
[6]:    ./chap1/1.2.md#1.2.1.2            "1.2.1.2 标准命令行选项"
[7]:    ./chap1/1.2.md#1.2.1.3            "1.2.1.3 非标准命令行选项"
[8]:    ./chap1/1.2.md#1.2.2              "1.2.2 行为差异"
[9]:    ./chap1/1.3.md                    "1.3 JRockit版本号的命名规则"
[10]:   ./chap1/1.4.md                    "1.4 获取帮助"
[11]:   ./chap1/1.5.md                    "1.5 小结"
[12]:   ./chap2/2.md                      "2 自适应代码生成"
[13]:   ./chap2/2.1.md                    "2.1 平台独立性"
[14]:   ./chap2/2.2.md                    "2.2 Java虚拟机"
[15]:   ./chap2/2.2.md#2.2.1              "2.2.1 基于栈的虚拟机"
[16]:   ./chap2/2.2.md#2.2.2              "2.2.2 字节码格式"
[17]:   ./chap2/2.2.md#2.2.2.1            "2.2.2.1 操作与操作数"
[18]:   ./chap2/2.2.md#2.2.2.2            "2.2.2.2 常量池"
[19]:   ./chap2/2.3.md                    "2.3 代码生成策略"
[20]:   ./chap2/2.3.md#2.3.1              "2.3.1 纯解释执行"
[21]:   ./chap2/2.3.md#2.3.2              "2.3.2 静态编译"
[22]:   ./chap2/2.3.md#2.3.3              "2.3.3 完全静态编译"
[23]:   ./chap2/2.3.md#2.3.4              "2.3.4 混合模式"
[24]:   ./chap2/2.4.md                    "2.4 自适应代码生成"
[25]:   ./chap2/2.4.md#2.4.1              "2.4.1 判断热方法"
[26]:   ./chap2/2.4.md#2.4.1.1            "2.4.1.1 调用计数器"
[27]:   ./chap2/2.4.md#2.4.1.2            "2.4.1.2 基于软件的线程采样"
[28]:   ./chap2/2.4.md#2.4.1.3            "2.4.1.3 硬件采样"
[29]:   ./chap2/2.4.md#2.4.2              "2.4.2 优化动态程序"
[30]:   ./chap2/2.5.md                    "2.5 深入JIT编译器"
[31]:   ./chap2/2.5.md#2.5.1              "2.5.1 处理字节码"
[32]:   ./chap2/2.5.md#2.5.1.1            "2.5.1.1 字节码混淆"
[33]:   ./chap2/2.5.md#2.5.2              "2.5.2 字节码“优化器”"
[34]:   ./chap2/2.5.md#2.5.2.1            "2.5.2.1 抽象语法树"
[35]:   ./chap2/2.5.md#2.5.3              "2.5.3 优化字节码"
[36]:   ./chap2/2.6.md                    "2.6 代码流水线"
[37]:   ./chap2/2.6.md#2.6.1              "2.6.1 为什么JRockit没有字节码解释器"
[38]:   ./chap2/2.6.md#2.6.2              "2.6.2 启动"
[39]:   ./chap2/2.6.md#2.6.3              "2.6.3 运行时代码生成"
[40]:   ./chap2/2.6.md#2.6.3.1            "2.6.3.1 Trampolines"
[41]:   ./chap2/2.6.md#2.6.3.2            "2.6.3.2 代码生成请求"
[42]:   ./chap2/2.6.md#2.6.3.3            "2.6.3.3 代码优化请求"
[43]:   ./chap2/2.6.md#2.6.3.4            "2.6.3.4 栈上替换"
[44]:   ./chap2/2.6.md#2.6.3.5            "2.6.3.5 簿记"
[45]:   ./chap2/2.6.md#2.6.4              "2.6.4 代码生成概述"
[46]:   ./chap2/2.6.md#2.6.4.1            "2.6.4.1 代码的中间表示"
[47]:   ./chap2/2.6.md#2.6.4.2            "2.6.4.2 JIT编译"
[48]:   ./chap2/2.6.md#2.6.4.3            "2.6.4.3 代码优化"
[49]:   ./chap2/2.7.md                    "2.7 控制代码生成"
[50]:   ./chap2/2.7.md#2.7.1              "2.7.1 命令行选项与指导文件"
[51]:   ./chap2/2.7.md#2.7.1.1            "2.7.1.1 命令行选项"
[52]:   ./chap2/2.7.md#2.7.1.2            "2.7.1.2 指导文件"
[53]:   ./chap2/2.8.md                    "2.8 小结"
[54]:   ./chap3/3.md                      "3 自适应内存管理"
[55]:   ./chap3/3.1.md                    "3.1 自动内存管理相关概念"
[56]:   ./chap3/3.1.md#3.1.1              "3.1.1 自适应内存管理"
[57]:   ./chap3/3.1.md#3.1.2              "3.1.2 自适应内存管理的优点"
[58]:   ./chap3/3.1.md#3.1.3              "3.1.3 自适应内存管理的缺点"
[59]:   ./chap3/3.2.md                    "3.2 堆管理基础"
[60]:   ./chap3/3.2.md#3.2.1              "3.2.1 对象的分配于释放"
[61]:   ./chap3/3.2.md#3.2.2              "3.2.2 碎片与整理"
[62]:   ./chap3/3.3.md                    "3.3 垃圾回收算法"
[63]:   ./chap3/3.3.md#3.3.1              "3.3.1 引用计数"
[64]:   ./chap3/3.3.md#3.3.2              "3.3.2 引用跟踪"
[65]:   ./chap3/3.3.md#3.3.2.1            "3.3.2.1 标记-清理"
[66]:   ./chap3/3.3.md#3.3.2.2            "3.3.2.2 暂停-拷贝"
[67]:   ./chap3/3.3.md#3.3.3              "3.3.3 STW(stop-the-world)"
[68]:   ./chap3/3.3.md#3.3.3.1            "3.3.3.1 保守式 vs. 准确式"
[69]:   ./chap3/3.3.md#3.3.3.2            "3.3.3.2 livemap"
[70]:   ./chap3/3.3.md#3.3.4              "3.3.4 分代垃圾回收"
[71]:   ./chap3/3.3.md#3.3.4.1            "3.3.4.1 多个新生代的内存排布"
[72]:   ./chap3/3.3.md#3.3.4.2            "3.3.4.2 写屏障"
[73]:   ./chap3/3.3.md#3.3.5              "3.3.5 吞吐量 vs. 延迟"
[74]:   ./chap3/3.3.md#3.3.5.1            "3.3.5.1 优化吞吐量"
[75]:   ./chap3/3.3.md#3.3.5.2            "3.3.5.2 优化延迟"
[76]:   ./chap3/3.3.md#3.3.6              "3.3.6 JRockit中的垃圾回收"
[77]:   ./chap3/3.3.md#3.3.6.1            "3.3.6.1 老年代垃圾回收"
[78]:   ./chap3/3.3.md#3.3.6.2            "3.3.6.2 新生代垃圾回收"
[79]:   ./chap3/3.3.md#3.3.6.3            "3.3.6.3 永生代垃圾回收"
[80]:   ./chap3/3.3.md#3.3.6.4            "3.3.6.4 内存整理"
[81]:   ./chap3/3.4.md                    "3.4 性能与伸缩性"
[82]:   ./chap3/3.4.md#3.4.1              "3.4.1 线程局部分配"
[83]:   ./chap3/3.4.md#3.4.2              "3.4.2 更大的堆内存"
[84]:   ./chap3/3.4.md#3.4.2.1            "3.4.2.1 32位架构下的4GB内存限制"
[85]:   ./chap3/3.4.md#3.4.2.2            "3.4.2.2 64位架构"
[86]:   ./chap3/3.4.md#3.4.3              "3.4.3 缓存友好性"
[87]:   ./chap3/3.4.md#3.4.3.1            "3.4.3.1 预抓取"
[88]:   ./chap3/3.4.md#3.4.3.2            "3.4.3.2 数据存放"
[89]:   ./chap3/3.4.md#3.4.4              "3.4.4 NUMA"
[90]:   ./chap3/3.4.md#3.4.5              "3.4.5 大内存页（Large pages）"
[91]:   ./chap3/3.4.md#3.4.6              "3.4.6 自适应（Adaptability）"
[92]:   ./chap3/3.5.md                    "3.5 近实时垃圾回收"
[93]:   ./chap3/3.5.md#3.5.1              "3.5.1 软实时与硬实时"
[94]:   ./chap3/3.5.md#3.5.2              "3.5.2 JRockit Real Time"
[95]:   ./chap3/3.5.md#3.5.2.1            "3.5.2.1 软实时有效么？"
[96]:   ./chap3/3.5.md#3.5.2.2            "3.5.2.2 工作原理"
[97]:   ./chap3/3.6.md                    "3.6 内存操作相关的API"
[98]:   ./chap3/3.6.md#3.6.1              "3.6.1 析构函数"
[99]:   ./chap3/3.6.md#3.6.2              "3.6.2 Java中的引用"
[100]:  ./chap3/3.6.md#3.6.2.1            "3.6.2.1 弱引用"
[101]:  ./chap3/3.6.md#3.6.2.2            "3.6.2.2 软引用"
[102]:  ./chap3/3.6.md#3.6.2.3            "3.6.2.3 虚引用"
[103]:  ./chap3/3.6.md#3.6.3              "3.6.3 JVM的行为差异"
[104]:  ./chap3/3.7.md                    "3.7 陷阱与伪优化"
[105]:  ./chap3/3.7.md#3.7.1              "3.7.1 Java不是C++"
[106]:  ./chap3/3.8.md                    "3.8 JRockit中的内存管理"
[107]:  ./chap3/3.8.md#3.8.1              "3.8.1 基本参数"
[108]:  ./chap3/3.8.md#3.8.1.1            "3.8.1.1 打印垃圾回收日志"
[109]:  ./chap3/3.8.md#3.8.1.2            "3.8.1.2 设置堆的初始值和最大值"
[110]:  ./chap3/3.8.md#3.8.1.3            "3.8.1.3 设置垃圾回收器的执行目标"
[111]:  ./chap3/3.8.md#3.8.1.4            "3.8.1.4 指定垃圾回收策略"
[112]:  ./chap3/3.8.md#3.8.2              "3.8.2 压缩引用"
[113]:  ./chap3/3.8.md#3.8.3              "3.8.3 高级选项"
[114]:  ./chap3/3.9.md                    "3.9 小结"