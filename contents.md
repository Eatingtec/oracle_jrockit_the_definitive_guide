#目录

* [1 起步][1]
    * [1.1 获得JRockit JVM][2]
    * [1.2 将应用程序迁移到JRockit][3]
        * [1.2.1 命令行选项][4]
            * [1.2.1.1 系统属性][5]
            * [1.2.1.2 标准命令行选项][6]
            * [1.2.1.3 非标准命令行选项][7]
        * [1.2.2 行为差异][8]
    * [1.3 JRockit版本号的命名规则][9]
    * [1.4 获取帮助][10]
    * [1.5 小结][11]
* [2 自适应代码生成][12]
    * [2.1 平台无关性][13]
    * [2.2 Java虚拟机][14]
        * [2.2.1 基于栈的虚拟机][15]
        * [2.2.2 字节码格式][16]
            * [2.2.2.1 操作与操作数][17]
            * [2.2.2.2 常量池][18]
    * [2.3 代码生成策略][19]
        * [2.3.1 纯解释执行][20]
        * [2.3.2 静态编译][21]
        * [2.3.3 完全JIT编译][22]
        * [2.3.4 混合模式][23]
    * [2.4 自适应代码生成][24]
        * [2.4.1 判断热方法][25]
            * [2.4.1.1 调用计数器][26]
            * [2.4.1.2 基于软件的线程采样][27]
            * [2.4.1.3 硬件采样][28]
        * [2.4.2 优化动态程序][29]
    * [2.5 深入JIT编译器][30]
        * [2.5.1 处理字节码][31]
            * [2.5.1.1 字节码混淆][32]
        * [2.5.2 字节码“优化器”][33]
            * [2.5.2.1 抽象语法树][34]
        * [2.5.3 优化字节码][35]
    * [2.6 代码流水线][36]
        * [2.6.1 为什么JRockit没有字节码解释器][37]
        * [2.6.2 启动][38]
        * [2.6.3 运行时代码生成][39]
            * [2.6.3.1 Trampolines][40]
            * [2.6.3.2 代码生成请求][41]
            * [2.6.3.3 代码优化请求][42]
            * [2.6.3.4 栈上替换][43]
            * [2.6.3.5 簿记][44]
        * [2.6.4 代码生成概述][45]
            * [2.6.4.1 代码的中间表示][46]
            * [2.6.4.2 JIT编译][47]
            * [2.6.4.3 代码优化][48]
    * [2.7 控制代码生成][49]
        * [2.7.1 命令行选项与指导文件][50]
            * [2.7.1.1 命令行选项][51]
            * [2.7.1.2 指导文件][52]
    * [2.8 小结][53]
* [3 自适应内存管理][54]
    * [3.1 自动内存管理相关概念][55]
        * [3.1.1 自适应内存管理][56]
        * [3.1.2 自动内存管理的优点][57]
        * [3.1.3 自动内存管理的缺点][58]
    * [3.2 堆管理基础][59]
        * [3.2.1 对象的分配于释放][60]
        * [3.2.2 碎片与整理][61]
    * [3.3 垃圾回收算法][62]
        * [3.3.1 引用计数][63]
        * [3.3.2 引用跟踪][64]
            * [3.3.2.1 标记-清理][65]
            * [3.3.2.2 暂停-拷贝][66]
        * [3.3.3 STW(stop-the-world)][67]
            * [3.3.3.1 保守式 vs. 准确式][68]
            * [3.3.3.2 livemap][69]
        * [3.3.4 分代垃圾回收][70]
            * [3.3.4.1 多个新生代的内存排布][71]
            * [3.3.4.2 写屏障][72]
        * [3.3.5 吞吐量 vs. 延迟][73]
            * [3.3.5.1 优化吞吐量][74]
            * [3.3.5.2 优化延迟][75]
        * [3.3.6 JRockit中的垃圾回收][76]
            * [3.3.6.1 老年代垃圾回收][77]
            * [3.3.6.2 新生代垃圾回收][78]
            * [3.3.6.3 永生代垃圾回收][79]
        * [3.3.6.4 内存整理][80]
    * [3.4 性能与伸缩性][81]
        * [3.4.1 线程局部分配][82]
        * [3.4.2 更大的堆内存][83]
            * [3.4.2.1 32位架构下的4GB内存限制][84]
            * [3.4.2.2 64位架构][85]
        * [3.4.3 缓存友好性][86]
            * [3.4.3.1 预抓取][87]
            * [3.4.3.2 数据存放][88]
        * [3.4.4 NUMA][89]
        * [3.4.5 大内存页（Large pages）][90]
        * [3.4.6 自适应（Adaptability）][91]
    * [3.5 近实时垃圾回收][92]
        * [3.5.1 软实时与硬实时][93]
        * [3.5.2 JRockit Real Time][94]
            * [3.5.2.1 软实时有效么？][95]
            * [3.5.2.2 工作原理][96]
    * [3.6 内存操作相关的API][97]
        * [3.6.1 析构函数][98]
        * [3.6.2 Java中的引用][99]
            * [3.6.2.1 弱引用][100]
            * [3.6.2.2 软引用][101]
            * [3.6.2.3 虚引用][102]
        * [3.6.3 JVM的行为差异][103]
    * [3.7 陷阱与伪优化][104]
        * [3.7.1 Java不是C++][105]
    * [3.8 JRockit中的内存管理][106]
        * [3.8.1 基本参数][107]
           * [3.8.1.1 打印垃圾回收日志][108]
           * [3.8.1.2 设置堆的初始值和最大值][109]
           * [3.8.1.3 设置垃圾回收器的执行目标][110]
           * [3.8.1.4 指定垃圾回收策略][111]
        * [3.8.2 压缩引用][112]
        * [3.8.3 高级选项][113]
    * [3.9 小结][114]
* [4 线程与同步][115]
    * [4.1 基本概念][116]
        * [4.1.1 难以调试][117]
        * [4.1.2 难以优化][118]
            * [4.1.2.1 延迟性分析][119]
    * [4.2 Java API][120]
        * [4.2.1 synchromized关键字][121]
        * [4.2.2 java.lang.Thread类][122]
        * [4.2.3 java.util.concurrent包][123]
        * [4.2.4 信号量][124]
        * [4.2.5 volatile关键字][125]
    * [4.3 Java中线程与同步机制的实现][126]
        * [4.3.1 Java内存模型][127]
            * [4.3.1.1 早期内存模型中的问题][128]
            * [4.3.1.2 JSR-133][129]
        * [4.3.2 同步的实现][130]
            * [4.3.2.1 原生机制][131]
            * [4.3.2.2 锁(Lock)][132]
        * [4.3.3 同步在字节码中的实现][133]
            * [4.3.3.1 匹配的锁操作][134]
        * [4.3.4 线程的实现][135]
            * [4.3.4.1 绿色线程（green thread）][136]
            * [4.3.4.2 操作系统线程][137]
    * [4.4 对于线程与同步的优化][138]
        * [4.4.1 锁膨胀与锁收缩][139]
        * [4.4.2 递归锁][140]
        * [4.4.3 锁融合][141]
        * [4.4.4 延迟解锁][142]
            * [4.4.4.1 实现][143]
            * [4.4.4.2 禁用对象][144]
            * [4.4.4.3 禁用类][145]
            * [4.4.4.4 结论][146]
    * [4.5 陷阱与伪优化][147]
        * [4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`][148]
        * [4.5.2 双检查锁][149]
    *[4.6 相关命令行参数][150]
        * [4.6.1 检查锁与延迟解锁][151]
            * [4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为][152]
            * [4.6.1.2 使用参数`-XX:UseLazyUnlocking`][153]
        * [4.6.2 输出调用栈信息][154]
        * [4.6.3 锁分析][155]
            * [4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析][156]
        * [4.6.4 设置线程栈的大小][157]
        * [4.6.5 使用命令行参数控制锁的行为][158]
    * [4.7 小结][159]
* [5 基准测试与性能调优][160]
    * [5.1 为何要进行基准测试][161]
        * [5.1.1 制定性能目标][162]
        * [5.1.2 对性能进行回归测试][163]
        * [5.1.3 确定优化方向][164]
        * [5.1.4 商业应用][165]
    * [5.2 如何构建基准测试][166]
        * [5.2.1 "置身事外（outside the system）"][167]
        * [5.2.2 测量时间][168]
        * [5.2.3 微基准测试（micro benchmark）][169]
            * [5.2.3.1 基准测试与栈上替换][170]
            * [5.2.3.2 基准测试与启动时间][171]
        * [5.2.4 测试前要热身][172]
    * [5.3 确定测试目标][173]
        * [5.3.1 吞吐量][174]
        * [5.3.2 兼顾吞吐量、响应时间和延迟][175]
        * [5.3.3 伸缩性][176]
        * [5.3.4 能源消耗][177]
        * [5.3.5 其他方面][178]
    * [5.4 工业级基准测试][179]
        * [5.4.1 SPEC基准测试套件][180]
            * [5.4.1.1 SPECjvm基准测试套件][181]
            * [5.4.1.2 SPECjAppServer套件/SPECjEnterprise2010套件][182]
            * [5.4.1.3 SPECjbb套件][183]
        * [5.4.2 SipStone基准测试][184]
        * [5.4.3 DaCapo基准测试][185]
        * [5.4.4 真实场景下的应用程序][186]
    * [5.5 基准测试的潜在风险][187]
    * [5.6 性能调优][188]
        * [5.6.1 非规范化行为（Out of the box behavior）][189]
        * [5.6.2 调优目标][190]
            * [5.6.2.1 内存管理调优][191]
            * [5.6.2.2 代码生成调优][192]
            * [5.6.2.3 锁与线程调优][193]
            * [5.6.2.4 其他相关调优][194]
    * [5.7 常见性能瓶颈与规避方法][195]
        * [5.7.1 命令行参数`–XXaggressive`][196]
        * [5.7.2 析构函数][197]
        * [5.7.3 引用对象][198]
        * [5.7.4 对象池][199]
        * [5.7.5 算法与数据结构][200]
            * [5.7.5.1 典型问题][201]
            * [5.7.5.2 意料之外的性质][202]
        * [5.7.6 误用`System.gc()`][203]
        * [5.7.7 线程数太多][204]
        * [5.7.8 锁竞争导致性能瓶颈][205]
        * [5.7.9 不必要的异常][206]
        * [5.7.10 大对象][207]
        * [5.7.11 本地内存 vs. 堆内存][208]
    * [5.8 `wait/notify`方法与胖锁][209]
        * [5.8.1 堆的大小设置不当][210]
        * [5.8.2 存活对象过多][211]
        * [5.8.3 Java并非银弹][212]
    * [5.9 小结][213]
* [6 JRockit Mission Control][214]
    * [6.1 相关背景][215]
        * [6.1.1 采样分析 vs. 准确分析][216]
        * [6.1.2 用途广泛][217]
    * [6.2 概述][218]
        * [6.2.1 JRockit Mission Control的服务器端组件][219]
        * [6.2.2 JRockit Mission Control的客户端组件][220]
        * [6.2.3 术语介绍][221]
        * [6.2.4 单独运行JRockit Mission Control][222]
        * [6.2.5 在Eclipse中运行JRockit Mission Control][223]
        * [6.2.6 远程管理JRockit][224]
            * [6.2.6.1 JRockit发现协议（JRockit Discovery Protocol）][225]
        * [6.2.7 安全限制][226]
    * [6.3 处理连接问题][227]
        * [6.3.1 主机名解析失败的问题][228]
    * [6.4 Experimental Update Site][229]
    * [6.5 调试JRockit Mission Control][230]
    * [6.6 小结][231]
* [7 Management Console][232]
    * [7.1 JMX Management Console][233]
    * [7.2 Management Console][234]
        * [7.2.1 一般信息][235]
            * [7.2.1.1 概览][236]
        * [7.2.2 MBean][237]
            * [7.2.2.1 MBean浏览器][238]
            * [7.2.2.2 触发器][239]
        * [7.2.3 运行时][240]
            * [7.2.3.1 系统标签页][241]
            * [7.2.3.2 内存标签页][242]
            * [7.2.3.3 线程标签页][243]
        * [7.2.4 高级标签组][244]
            * [7.2.4.1 方法概要分析][245]
            * [7.2.4.2 异常标签页][246]
            * [7.2.4.3 诊断命令标签页][247]
        * [7.2.5 其他标签组][248]
            * [7.2.5.1 JConsole][249]
    * [7.3 扩展JRockit Mission Control Console][250]
    * [7.4 小结][251]
* [8 运行时分析器][252]
    * [8.1 反馈信息的必要性][253]
        * [8.1.1 记录][254]
    * [8.2 分析JRA记录][255]
        * [8.2.1 General标签组][256]
            * [8.2.1.1 Overview标签页][257]
            * [8.2.1.2 Recoding标签页][258]
            * [8.2.1.3 System标签页][259]
        * [8.2.2 Memory标签组][260]
            * [8.2.2.1 Overview标签页][261]
            * [8.2.2.2 GC标签页][262]
            * [8.2.2.3 GC统计信息标签页][263]
            * [8.2.2.4 内存分配标签页][264]
            * [8.2.2.5 堆信息标签页][265]
            * [8.2.2.6 对象统计标签页][266]
        * [8.2.3 代码标签组][267]
            * [8.2.3.1 概览标签页][268]
            * [8.2.3.2 热点方法标签页][269]
            * [8.2.3.3 优化标签页][270]
        * [8.2.4 线程/锁标签组][271]
            * [8.2.4.1 概览标签页][272]
            * [8.2.4.2 线程标签页][273]
            * [8.2.4.3 Java锁标签页][274]
            * [8.2.4.4 JVM锁标签页][275]
            * [8.2.4.5 线程转储标签页][276]
        * [8.2.5 延迟标签组][277]
            * [8.2.5.1 概览标签页][278]
            * [8.2.5.2 日志标签页][279]
            * [8.2.5.3 图形标签页][280]
            * [8.2.5.4 线程标签页][281]
            * [8.2.5.5 堆栈跟踪标签页][282]
            * [8.2.5.6 直方图标签页][283]
        * [8.2.6 使用操作集][284]
    * [8.3 故障排除][285]
    * [8.4 小结][286]







[1]:    ./chap1/1.md#1                    "1 起步"
[2]:    ./chap1/1.1.md#1.1                "1.1 获得JRockit JVM"
[3]:    ./chap1/1.2.md#1.2                "1.2 将应用程序迁移到JRockit"
[4]:    ./chap1/1.2.md#1.2.1              "1.2.1 命令行选项"
[5]:    ./chap1/1.2.md#1.2.1.1            "1.2.1.1 系统属性"
[6]:    ./chap1/1.2.md#1.2.1.2            "1.2.1.2 标准命令行选项"
[7]:    ./chap1/1.2.md#1.2.1.3            "1.2.1.3 非标准命令行选项"
[8]:    ./chap1/1.2.md#1.2.2              "1.2.2 行为差异"
[9]:    ./chap1/1.3.md#1.3                "1.3 JRockit版本号的命名规则"
[10]:   ./chap1/1.4.md#1.4                "1.4 获取帮助"
[11]:   ./chap1/1.5.md#1.5                "1.5 小结"
[12]:   ./chap2/2.md#2                    "2 自适应代码生成"
[13]:   ./chap2/2.1.md#2.1                "2.1 平台独立性"
[14]:   ./chap2/2.2.md#2.2                "2.2 Java虚拟机"
[15]:   ./chap2/2.2.md#2.2.1              "2.2.1 基于栈的虚拟机"
[16]:   ./chap2/2.2.md#2.2.2              "2.2.2 字节码格式"
[17]:   ./chap2/2.2.md#2.2.2.1            "2.2.2.1 操作与操作数"
[18]:   ./chap2/2.2.md#2.2.2.2            "2.2.2.2 常量池"
[19]:   ./chap2/2.3.md#2.3                "2.3 代码生成策略"
[20]:   ./chap2/2.3.md#2.3.1              "2.3.1 纯解释执行"
[21]:   ./chap2/2.3.md#2.3.2              "2.3.2 静态编译"
[22]:   ./chap2/2.3.md#2.3.3              "2.3.3 完全静态编译"
[23]:   ./chap2/2.3.md#2.3.4              "2.3.4 混合模式"
[24]:   ./chap2/2.4.md#2.4                "2.4 自适应代码生成"
[25]:   ./chap2/2.4.md#2.4.1              "2.4.1 判断热方法"
[26]:   ./chap2/2.4.md#2.4.1.1            "2.4.1.1 调用计数器"
[27]:   ./chap2/2.4.md#2.4.1.2            "2.4.1.2 基于软件的线程采样"
[28]:   ./chap2/2.4.md#2.4.1.3            "2.4.1.3 硬件采样"
[29]:   ./chap2/2.4.md#2.4.2              "2.4.2 优化动态程序"
[30]:   ./chap2/2.5.md#2.5                "2.5 深入JIT编译器"
[31]:   ./chap2/2.5.md#2.5.1              "2.5.1 处理字节码"
[32]:   ./chap2/2.5.md#2.5.1.1            "2.5.1.1 字节码混淆"
[33]:   ./chap2/2.5.md#2.5.2              "2.5.2 字节码“优化器”"
[34]:   ./chap2/2.5.md#2.5.2.1            "2.5.2.1 抽象语法树"
[35]:   ./chap2/2.5.md#2.5.3              "2.5.3 优化字节码"
[36]:   ./chap2/2.6.md#2.6                "2.6 代码流水线"
[37]:   ./chap2/2.6.md#2.6.1              "2.6.1 为什么JRockit没有字节码解释器"
[38]:   ./chap2/2.6.md#2.6.2              "2.6.2 启动"
[39]:   ./chap2/2.6.md#2.6.3              "2.6.3 运行时代码生成"
[40]:   ./chap2/2.6.md#2.6.3.1            "2.6.3.1 Trampolines"
[41]:   ./chap2/2.6.md#2.6.3.2            "2.6.3.2 代码生成请求"
[42]:   ./chap2/2.6.md#2.6.3.3            "2.6.3.3 代码优化请求"
[43]:   ./chap2/2.6.md#2.6.3.4            "2.6.3.4 栈上替换"
[44]:   ./chap2/2.6.md#2.6.3.5            "2.6.3.5 簿记"
[45]:   ./chap2/2.6.md#2.6.4              "2.6.4 代码生成概述"
[46]:   ./chap2/2.6.md#2.6.4.1            "2.6.4.1 代码的中间表示"
[47]:   ./chap2/2.6.md#2.6.4.2            "2.6.4.2 JIT编译"
[48]:   ./chap2/2.6.md#2.6.4.3            "2.6.4.3 代码优化"
[49]:   ./chap2/2.7.md#2.7                "2.7 控制代码生成"
[50]:   ./chap2/2.7.md#2.7.1              "2.7.1 命令行选项与指导文件"
[51]:   ./chap2/2.7.md#2.7.1.1            "2.7.1.1 命令行选项"
[52]:   ./chap2/2.7.md#2.7.1.2            "2.7.1.2 指导文件"
[53]:   ./chap2/2.8.md#2.8                "2.8 小结"
[54]:   ./chap3/3.md#3                    "3 自适应内存管理"
[55]:   ./chap3/3.1.md#3.1                "3.1 自动内存管理相关概念"
[56]:   ./chap3/3.1.md#3.1.1              "3.1.1 自适应内存管理"
[57]:   ./chap3/3.1.md#3.1.2              "3.1.2 自适应内存管理的优点"
[58]:   ./chap3/3.1.md#3.1.3              "3.1.3 自适应内存管理的缺点"
[59]:   ./chap3/3.2.md#3.2                "3.2 堆管理基础"
[60]:   ./chap3/3.2.md#3.2.1              "3.2.1 对象的分配于释放"
[61]:   ./chap3/3.2.md#3.2.2              "3.2.2 碎片与整理"
[62]:   ./chap3/3.3.md#3.3                "3.3 垃圾回收算法"
[63]:   ./chap3/3.3.md#3.3.1              "3.3.1 引用计数"
[64]:   ./chap3/3.3.md#3.3.2              "3.3.2 引用跟踪"
[65]:   ./chap3/3.3.md#3.3.2.1            "3.3.2.1 标记-清理"
[66]:   ./chap3/3.3.md#3.3.2.2            "3.3.2.2 暂停-拷贝"
[67]:   ./chap3/3.3.md#3.3.3              "3.3.3 STW(stop-the-world)"
[68]:   ./chap3/3.3.md#3.3.3.1            "3.3.3.1 保守式 vs. 准确式"
[69]:   ./chap3/3.3.md#3.3.3.2            "3.3.3.2 livemap"
[70]:   ./chap3/3.3.md#3.3.4              "3.3.4 分代垃圾回收"
[71]:   ./chap3/3.3.md#3.3.4.1            "3.3.4.1 多个新生代的内存排布"
[72]:   ./chap3/3.3.md#3.3.4.2            "3.3.4.2 写屏障"
[73]:   ./chap3/3.3.md#3.3.5              "3.3.5 吞吐量 vs. 延迟"
[74]:   ./chap3/3.3.md#3.3.5.1            "3.3.5.1 优化吞吐量"
[75]:   ./chap3/3.3.md#3.3.5.2            "3.3.5.2 优化延迟"
[76]:   ./chap3/3.3.md#3.3.6              "3.3.6 JRockit中的垃圾回收"
[77]:   ./chap3/3.3.md#3.3.6.1            "3.3.6.1 老年代垃圾回收"
[78]:   ./chap3/3.3.md#3.3.6.2            "3.3.6.2 新生代垃圾回收"
[79]:   ./chap3/3.3.md#3.3.6.3            "3.3.6.3 永生代垃圾回收"
[80]:   ./chap3/3.3.md#3.3.6.4            "3.3.6.4 内存整理"
[81]:   ./chap3/3.4.md#3.4                "3.4 性能与伸缩性"
[82]:   ./chap3/3.4.md#3.4.1              "3.4.1 线程局部分配"
[83]:   ./chap3/3.4.md#3.4.2              "3.4.2 更大的堆内存"
[84]:   ./chap3/3.4.md#3.4.2.1            "3.4.2.1 32位架构下的4GB内存限制"
[85]:   ./chap3/3.4.md#3.4.2.2            "3.4.2.2 64位架构"
[86]:   ./chap3/3.4.md#3.4.3              "3.4.3 缓存友好性"
[87]:   ./chap3/3.4.md#3.4.3.1            "3.4.3.1 预抓取"
[88]:   ./chap3/3.4.md#3.4.3.2            "3.4.3.2 数据存放"
[89]:   ./chap3/3.4.md#3.4.4              "3.4.4 NUMA"
[90]:   ./chap3/3.4.md#3.4.5              "3.4.5 大内存页（Large pages）"
[91]:   ./chap3/3.4.md#3.4.6              "3.4.6 自适应（Adaptability）"
[92]:   ./chap3/3.5.md#3.5                "3.5 近实时垃圾回收"
[93]:   ./chap3/3.5.md#3.5.1              "3.5.1 软实时与硬实时"
[94]:   ./chap3/3.5.md#3.5.2              "3.5.2 JRockit Real Time"
[95]:   ./chap3/3.5.md#3.5.2.1            "3.5.2.1 软实时有效么？"
[96]:   ./chap3/3.5.md#3.5.2.2            "3.5.2.2 工作原理"
[97]:   ./chap3/3.6.md#3.6                "3.6 内存操作相关的API"
[98]:   ./chap3/3.6.md#3.6.1              "3.6.1 析构函数"
[99]:   ./chap3/3.6.md#3.6.2              "3.6.2 Java中的引用"
[100]:  ./chap3/3.6.md#3.6.2.1            "3.6.2.1 弱引用"
[101]:  ./chap3/3.6.md#3.6.2.2            "3.6.2.2 软引用"
[102]:  ./chap3/3.6.md#3.6.2.3            "3.6.2.3 虚引用"
[103]:  ./chap3/3.6.md#3.6.3              "3.6.3 JVM的行为差异"
[104]:  ./chap3/3.7.md#3.7                "3.7 陷阱与伪优化"
[105]:  ./chap3/3.7.md#3.7.1              "3.7.1 Java不是C++"
[106]:  ./chap3/3.8.md#3.8                "3.8 JRockit中的内存管理"
[107]:  ./chap3/3.8.md#3.8.1              "3.8.1 基本参数"
[108]:  ./chap3/3.8.md#3.8.1.1            "3.8.1.1 打印垃圾回收日志"
[109]:  ./chap3/3.8.md#3.8.1.2            "3.8.1.2 设置堆的初始值和最大值"
[110]:  ./chap3/3.8.md#3.8.1.3            "3.8.1.3 设置垃圾回收器的执行目标"
[111]:  ./chap3/3.8.md#3.8.1.4            "3.8.1.4 指定垃圾回收策略"
[112]:  ./chap3/3.8.md#3.8.2              "3.8.2 压缩引用"
[113]:  ./chap3/3.8.md#3.8.3              "3.8.3 高级选项"
[114]:  ./chap3/3.9.md#3.9                "3.9 小结"
[115]:  ./chap4/4.md#4                    "4 线程与同步"
[116]:  ./chap4/4.1.md#4.1                "4.1 基本概念"
[117]:  ./cgap4/4.1.md#4.1.1              "4.1.1 难以调试"
[118]:  ./chap4/4.1.md#4.1.2              "4.1.2 难以优化"
[119]:  ./chap4/4.1.md#4.1.2.1            "4.1.2.1 延迟分析"
[120]:  ./chap4/4.2.md#4.2                "4.2 Java API"
[121]:  ./chap4/4.2.md#4.2.1              "4.2.1 synchronized关键字"
[122]:  ./chap4/4.2.md#4.2.2              "4.2.2 java.lang.Thread类"
[123]:  ./chap4/4.2.md#4.2.3              "4.2.3 java.util.concurrent包"
[124]:  ./chap4/4.2.md#4.2.4              "4.2.4 信号量"
[125]:  ./chap4/4.2.md#4.2.5              "4.2.5 volatile关键字"
[126]:  ./chap4/4.3.md#4.3                "4.3 Java中线程与同步机制的实现"
[127]:  ./chap4/4.3.md#4.3.1              "4.3.1 Java内存模型"
[128]:  ./chap4/4.3.md#4.3.1.1            "4.3.1.1 早期内存模型中的问题"
[129]:  ./chap4/4.3.md#4.3.1.2            "4.3.1.2 JSR-133"
[130]:  ./chap4/4.3.md#4.3.2              "4.3.2 同步的实现"
[131]:  ./chap4/4.3.md#4.3.2.1            "4.3.2.1 原生机制"
[132]:  ./chap4/4.3.md#4.3.2.2            "4.3.2.2 锁(Lock)"
[133]:  ./chap4/4.3.md#4.3.3              "4.3.3 同步在字节码中的实现"
[134]:  ./chap4/4.3.md#4.3.3.1            "4.3.3.1 匹配的锁操作"
[135]:  ./chap4/4.3.md#4.3.4              "4.3.4 线程的实现"
[136]:  ./chap4/4.3.md#4.3.4.1            "4.3.4.1 绿色线程（green thread）"
[137]:  ./chap4/4.3.md#4.3.4.2            "4.3.4.2 操作系统线程"
[138]:  ./chap4/4.4.md#4.4                "4.4 对于线程与同步的优化"
[139]:  ./chap4/4.4.md#4.4.1              "4.4.1 锁膨胀与锁收缩"
[140]:  ./chap4/4.4.md#4.4.2              "4.4.2 递归锁"
[141]:  ./chap4/4.4.md#4.4.3              "4.4.3 锁融合"
[142]:  ./chap4/4.4.md#4.4.4              "4.4.4 延迟解锁"
[143]:  ./chap4/4.4.md#4.4.4.1            "4.4.4.1 实现"
[144]:  ./chap4/4.4.md#4.4.4.2            "4.4.4.2 禁用对象"
[145]:  ./chap4/4.4.md#4.4.4.3            "4.4.4.3 禁用类"
[146]:  ./chap4/4.4.md#4.4.4.4            "4.4.4.4 结论"
[147]:  ./chap4/4.5.md#4.5                "4.5 陷阱与伪优化"
[148]:  ./chap4/4.5.md#4.5.1              "4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`"
[149]:  ./chap4/4.5.md#4.5.2              "4.5.2 双检查锁"
[150]:  ./chap4/4.6.md#4.6                "4.6 相关命令行参数"
[151]:  ./chap4/4.6.md#4.6.1              "4.6.1 检查锁与延迟解锁"
[152]:  ./chap4/4.6.md#4.6.1.1            "4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为"
[153]:  ./chap4/4.6.md#4.6.1.2            "4.6.1.2 使用参数`-XX:UseLazyUnlocking`"
[154]:  ./chap4/4.6.md#4.6.2              "4.6.2 输出调用栈信息"
[155]:  ./chap4/4.6.md#4.6.3              "4.6.3 锁分析"
[156]:  ./chap4/4.6.md#4.6.3.1            "4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析"
[157]:  ./chap4/4.6.md#4.6.4              "4.6.4 设置线程栈的大小"
[158]:  ./chap4/4.6.md#4.6.5              "4.6.5 使用命令行参数控制锁的行为"
[159]:  ./chap4/4.7.md#4.7                "4.7 小结"
[160]:  ./chap5/5.md#5                    "5 基准测试与性能调优"
[161]:  ./chap5/5.1.md#5.1                "5.1 为何要进行基准测试"
[162]:  ./chap5/5.1.md#5.1.1              "5.1.1 制定性能目标"
[163]:  ./chap5/5.1.md#5.1.2              "5.1.2 对性能进行回归测试"
[164]:  ./chap5/5.1.md#5.1.3              "5.1.3 确定优化方向"
[165]:  ./chap5/5.1.md#5.1.4              "5.1.4 商业应用"
[166]:  ./chap5/5.2.md#5.2                "5.2 如何构建基准测试"
[167]:  ./chap5/5.2.md#5.2.1              "5.2.1 "置身事外（outside the system）""
[168]:  ./chap5/5.2.md#5.2.2              "5.2.2 测量时间"
[169]:  ./chap5/5.2.md#5.2.3              "5.2.3 微基准测试（micro benchmark）"
[170]:  ./chap5/5.2.md#5.2.3.1            "5.2.3.1 基准测试与栈上替换"
[171]:  ./chap5/5.2.md#5.2.3.2            "5.2.3.2 基准测试与启动时间"
[172]:  ./chap5/5.2.md#5.2.4              "5.2.4 测试前要热身"
[173]:  ./chap5/5.3.md#5.3                "5.3 确定测试目标"
[174]:  ./chap5/5.3.md#5.3.1              "5.3.1 吞吐量"
[175]:  ./chap5/5.3.md#5.3.2              "5.3.2 兼顾吞吐量、响应时间和延迟"
[176]:  ./chap5/5.3.md#5.3.3              "5.3.3 伸缩性"
[177]:  ./chap5/5.3.md#5.3.4              "5.3.4 能源消耗"
[178]:  ./chap5/5.3.md#5.3.5              "5.3.5 其他方面"
[179]:  ./chap5/5.4.md#5.4                "5.4 工业级基准测试"
[180]:  ./chap5/5.4.md#5.4.1              "5.4.1 SPEC基准测试套件"
[181]:  ./chap5/5.4.md#5.4.1.1            "5.4.1.1 SPECjvm基准测试套件"
[182]:  ./chap5/5.4.md#5.4.1.2            "5.4.1.2 SPECjAppServer套件/SPECjEnterprise2010套件"
[183]:  ./chap5/5.4.md#5.4.1.3            "5.4.1.3 SPECjbb套件"
[184]:  ./chap5/5.4.md#5.4.2              "5.4.2 SipStone基准测试"
[185]:  ./chap5/5.4.md#5.4.3              "5.4.3 DaCapo基准测试"
[186]:  ./chap5/5.4.md#5.4.4              "5.4.4 真实场景下的应用程序"
[187]:  ./chap5/5.5.md#5.5                "5.5 基准测试的潜在风险"
[188]:  ./chap5/5.6.md#5.6                "5.6 性能调优"
[189]:  ./chap5/5.6.md#5.6.1              "5.6.1 非规范化行为（Out of the box behavior）"
[190]:  ./chap5/5.6.md#5.6.2              "5.6.2 调优目标"
[191]:  ./chap5/5.6.md#5.6.2.1            "5.6.2.1 内存管理调优"
[192]:  ./chap5/5.6.md#5.6.2.2            "5.6.2.2 代码生成调优"
[193]:  ./chap5/5.6.md#5.6.2.3            "5.6.2.3 锁与线程调优"
[194]:  ./chap5/5.6.md#5.6.2.4            "5.6.2.4 其他相关调优"
[195]:  ./chap5/5.7.md#5.7                "5.7 常见性能瓶颈与规避方法"
[196]:  ./chap5/5.7.md#5.7.1              "5.7.1 命令行参数`–XXaggressive`"
[197]:  ./chap5/5.7.md#5.7.2              "5.7.2 析构函数"
[198]:  ./chap5/5.7.md#5.7.3              "5.7.3 引用对象"
[199]:  ./chap5/5.7.md#5.7.4              "5.7.4 对象池"
[200]:  ./chap5/5.7.md#5.7.5              "5.7.5 算法与数据结构"
[201]:  ./chap5/5.7.md#5.7.5.1            "5.7.5.1 典型问题"
[202]:  ./chap5/5.7.md#5.7.5.2            "5.7.5.2 意料之外的性质"
[203]:  ./chap5/5.7.md#5.7.6              "5.7.6 误用`System.gc()`"
[204]:  ./chap5/5.7.md#5.7.7              "5.7.7 线程数太多"
[205]:  ./chap5/5.7.md#5.7.8              "5.7.8 锁竞争导致性能瓶颈"
[206]:  ./chap5/5.7.md#5.7.9              "5.7.9 不必要的异常"
[207]:  ./chap5/5.7.md#5.7.10             "5.7.10 大对象"
[208]:  ./chap5/5.7.md#5.7.11             "5.7.11 本地内存 vs. 堆内存"
[209]:  ./chap5/5.8.md#5.8                "5.8 `wait/notify`方法与胖锁"
[210]:  ./chap5/5.8.md#5.8.1              "5.8.1 堆的大小设置不当"
[211]:  ./chap5/5.8.md#5.8.2              "5.8.2 存活对象过多"
[212]:  ./chap5/5.8.md#5.8.3              "5.8.3 Java并非银弹"
[213]:  ./chap5/5.9.md#5.9                "5.9 小结"
[214]:  ./chap6/6.md#6                    "6 JRockit Mission Control"
[215]:  ./chap6/6.1.md#6.1                "6.1 相关背景"
[216]:  ./chap6/6.1.md#6.1.1              "6.1.1 采样分析 vs. 准确分析"
[217]:  ./chap6/6.1.md#6.1.2              "6.1.2 用途广泛"
[218]:  ./chap6/6.2.md#6.2                "6.2 概述"
[219]:  ./chap6/6.2.md#6.2.1              "6.2.1 JRockit Mission Control的服务器端组件"
[220]:  ./chap6/6.2.md#6.2.2              "6.2.2 JRockit Mission Control的客户端组件"
[221]:  ./chap6/6.2.md#6.2.3              "6.2.3 术语介绍"
[222]:  ./chap6/6.2.md#6.2.4              "6.2.4 单独运行JRockit Mission Control"
[223]:  ./chap6/6.2.md#6.2.5              "6.2.5 在Eclipse中运行JRockit Mission Control"
[224]:  ./chap6/6.2.md#6.2.6              "6.2.6 远程管理JRockit"
[225]:  ./chap6/6.2.md#6.2.6.1            "6.2.6.1 JRockit发现协议（JRockit Discovery Protocol）"
[226]:  ./chap6/6.2.md#6.2.7              "6.2.7 安全限制"
[227]:  ./chap6/6.3.md#6.3                "6.3 处理连接问题"
[228]:  ./chap6/6.3.md#6.3.1              "6.3.1 主机名解析失败的问题"
[229]:  ./chap6/6.4.md#6.4                "6.4 Experimental Update Site"
[230]:  ./chap6/6.5.md#6.5                "6.5 调试JRockit Mission Control"
[231]:  ./chap6.6.6.md#6.6                "6.6 小结"
[232]:  ./chap7/7.md#7                    "7 Management Console"
[233]:  ./chap7/7.1.md#7.1                "7.1 JMX Management Console"
[234]:  ./chap7/7.2.md#7.2                "7.2 Management Console"
[235]:  ./chap7/7.2.md#7.2.1              "7.2.1 一般信息"
[236]:  ./chap7/7.2.md#7.2.1.1            "7.2.1.1 概览"
[237]:  ./chap7/7.2.md#7.2.2              "7.2.2 MBean"
[238]:  ./chap7/7.2.md#7.2.2.1            "7.2.2.1 MBean浏览器"
[239]:  ./chap7/7.2.md#7.2.2.2            "7.2.2.2 触发器"
[240]:  ./chap7/7.2.md#7.2.3              "7.2.3 运行时"
[241]:  ./chap7/7.2.md#7.2.3.1            "7.2.3.1 系统标签页"
[242]:  ./chap7/7.2.md#7.2.3.2            "7.2.3.2 内存标签页"
[243]:  ./chap7/7.2.md#7.2.3.3            "7.2.3.3 线程标签页"
[244]:  ./chap7/7.2.md#7.2.4              "7.2.4 高级标签组"
[245]:  ./chap7/7.2.md#7.2.4.1            "7.2.4.1 方法概要分析"
[246]:  ./chap7/7.2.md#7.2.4.2            "7.2.4.2 异常标签页"
[247]:  ./chap7/7.2.md#7.2.4.3            "7.2.4.3 诊断命令标签页"
[248]:  ./chap7/7.2.md#7.2.5              "7.2.5 其他标签组"
[249]:  ./chap7/7.2.md#7.2.5.1            "7.2.5.1 JConsole"
[250]:  ./chap7/7.3.md#7.3                "7.3 扩展JRockit Mission Control Console"
[251]:  ./chap7/7.4.md#7.4                "7.4 小结"
[252]:  ./chap8/8.md#8                    "8 运行时分析器"
[253]:  ./chap8/8.1.md#8.1                "8.1 反馈信息的必要性"
[254]:  ./chap8/8.1.md#8.1.1              "8.1.1 记录"
[255]:  ./chap8/8.2.md#8.2                "8.2 分析JRA记录"
[256]:  ./chap8/8.2.md#8.2.1              "8.2.1 General标签组"
[257]:  ./chap8/8.2.md#8.2.1.1            "8.2.1.1 Overview标签页"
[258]:  ./chap8/8.2.md#8.2.1.2            "8.2.1.2 Recoding标签页"
[259]:  ./chap8/8.2.md#8.2.1.3            "8.2.1.3 System标签页"
[260]:  ./chap8/8.2.md#8.2.2              "8.2.2 Memory标签组"
[261]:  ./chap8/8.2.md#8.2.2.1            "8.2.2.1 Overview标签页"
[262]:  ./chap8/8.2.md#8.2.2.2            "8.2.2.2 GC标签页"
[263]:  ./chap8/8.2.md#8.2.2.3            "8.2.2.3 GC统计信息标签页"
[264]:  ./chap8/8.2.md#8.2.2.4            "8.2.2.4 内存分配标签页"
[265]:  ./chap8/8.2.md#8.2.2.5            "8.2.2.5 堆信息标签页"
[266]:  ./chap8/8.2.md#8.2.2.6            "8.2.2.6 对象统计标签页"
[267]:  ./chap8/8.2.md#8.2.3              "8.2.3 代码标签组"
[268]:  ./chap8/8.2.md#8.2.3.1            "8.2.3.1 概览标签页"
[269]:  ./chap8/8.2.md#8.2.3.2            "8.2.3.2 热点方法标签页"
[270]:  ./chap8/8.2.md#8.2.3.3            "8.2.3.3 优化标签页"
[271]:  ./chap8/8.2.md#8.2.4              "8.2.4 线程/锁标签组"
[272]:  ./chap8/8.2.md#8.2.4.1            "8.2.4.1 概览标签页"
[273]:  ./chap8/8.2.md#8.2.4.2            "8.2.4.2 线程标签页"
[274]:  ./chap8/8.2.md#8.2.4.3            "8.2.4.3 Java锁标签页"
[275]:  ./chap8/8.2.md#8.2.4.4            "8.2.4.4 JVM锁标签页"
[276]:  ./chap8/8.2.md#8.2.4.5            "8.2.4.5 线程转储标签页"
[277]:  ./chap8/8.2.md#8.2.5              "8.2.5 延迟标签组"
[278]:  ./chap8/8.2.md#8.2.5.1            "8.2.5.1 概览标签页"
[279]:  ./chap8/8.2.md#8.2.5.2            "8.2.5.2 日志标签页"
[280]:  ./chap8/8.2.md#8.2.5.3            "8.2.5.3 图形标签页"
[281]:  ./chap8/8.2.md#8.2.5.4            "8.2.5.4 线程标签页"
[282]:  ./chap8/8.2.md#8.2.5.5            "8.2.5.5 堆栈跟踪标签页"
[283]:  ./chap8/8.2.md#8.2.5.6            "8.2.5.6 直方图标签页"
[284]:  ./chap8/8.2.md#8.2.6              "8.2.6 使用操作集"
[285]:  ./chap8/8.3.md#8.3                "8.3 故障排除"
[286]:  ./chap8/8.4.md#8.4                "8.4 小结"