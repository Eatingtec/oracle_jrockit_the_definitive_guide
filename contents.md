#目录

* [1 起步][1]
    * [1.1 获得JRockit JVM][2]
    * [1.2 将应用程序迁移到JRockit][3]
        * [1.2.1 命令行选项][4]
            * [1.2.1.1 系统属性][5]
            * [1.2.1.2 标准命令行选项][6]
            * [1.2.1.3 非标准命令行选项][7]
        * [1.2.2 行为差异][8]
    * [1.3 JRockit版本号的命名规则][9]
    * [1.4 获取帮助][10]
    * [1.5 小结][11]
* [2 自适应代码生成][12]
    * [2.1 平台无关性][13]
    * [2.2 Java虚拟机][14]
        * [2.2.1 基于栈的虚拟机][15]
        * [2.2.2 字节码格式][16]
            * [2.2.2.1 操作与操作数][17]
            * [2.2.2.2 常量池][18]
    * [2.3 代码生成策略][19]
        * [2.3.1 纯解释执行][20]
        * [2.3.2 静态编译][21]
        * [2.3.3 完全JIT编译][22]
        * [2.3.4 混合模式][23]
    * [2.4 自适应代码生成][24]
        * [2.4.1 判断热方法][25]
            * [2.4.1.1 调用计数器][26]
            * [2.4.1.2 基于软件的线程采样][27]
            * [2.4.1.3 硬件采样][28]
        * [2.4.2 优化动态程序][29]
    * [2.5 深入JIT编译器][30]
        * [2.5.1 处理字节码][31]
            * [2.5.1.1 字节码混淆][32]
        * [2.5.2 字节码“优化器”][33]
            * [2.5.2.1 抽象语法树][34]
        * [2.5.3 优化字节码][35]
    * [2.6 代码流水线][36]
        * [2.6.1 为什么JRockit没有字节码解释器][37]
        * [2.6.2 启动][38]
        * [2.6.3 运行时代码生成][39]
            * [2.6.3.1 Trampolines][40]
            * [2.6.3.2 代码生成请求][41]
            * [2.6.3.3 代码优化请求][42]
            * [2.6.3.4 栈上替换][43]
            * [2.6.3.5 簿记][44]
        * [2.6.4 代码生成概述][45]
            * [2.6.4.1 代码的中间表示][46]
            * [2.6.4.2 JIT编译][47]
            * [2.6.4.3 代码优化][48]
    * [2.7 控制代码生成][49]
        * [2.7.1 命令行选项与指导文件][50]
            * [2.7.1.1 命令行选项][51]
            * [2.7.1.2 指导文件][52]
    * [2.8 小结][53]
* [3 自适应内存管理][54]
    * [3.1 自动内存管理相关概念][55]
        * [3.1.1 自适应内存管理][56]
        * [3.1.2 自动内存管理的优点][57]
        * [3.1.3 自动内存管理的缺点][58]
    * [3.2 堆管理基础][59]
        * [3.2.1 对象的分配于释放][60]
        * [3.2.2 碎片与整理][61]
    * [3.3 垃圾回收算法][62]
        * [3.3.1 引用计数][63]
        * [3.3.2 引用跟踪][64]
            * [3.3.2.1 标记-清理][65]
            * [3.3.2.2 暂停-拷贝][66]
        * [3.3.3 STW(stop-the-world)][67]
            * [3.3.3.1 保守式 vs. 准确式][68]
            * [3.3.3.2 livemap][69]
        * [3.3.4 分代垃圾回收][70]
            * [3.3.4.1 多个新生代的内存排布][71]
            * [3.3.4.2 写屏障][72]
        * [3.3.5 吞吐量 vs. 延迟][73]
            * [3.3.5.1 优化吞吐量][74]
            * [3.3.5.2 优化延迟][75]
        * [3.3.6 JRockit中的垃圾回收][76]
            * [3.3.6.1 老年代垃圾回收][77]
            * [3.3.6.2 新生代垃圾回收][78]
            * [3.3.6.3 永生代垃圾回收][79]
        * [3.3.6.4 内存整理][80]
    * [3.4 性能与伸缩性][81]
        * [3.4.1 线程局部分配][82]
        * [3.4.2 更大的堆内存][83]
            * [3.4.2.1 32位架构下的4GB内存限制][84]
            * [3.4.2.2 64位架构][85]
        * [3.4.3 缓存友好性][86]
            * [3.4.3.1 预抓取][87]
            * [3.4.3.2 数据存放][88]
        * [3.4.4 NUMA][89]
        * [3.4.5 大内存页（Large pages）][90]
        * [3.4.6 自适应（Adaptability）][91]
    * [3.5 近实时垃圾回收][92]
        * [3.5.1 软实时与硬实时][93]
        * [3.5.2 JRockit Real Time][94]
            * [3.5.2.1 软实时有效么？][95]
            * [3.5.2.2 工作原理][96]
    * [3.6 内存操作相关的API][97]
        * [3.6.1 析构函数][98]
        * [3.6.2 Java中的引用][99]
            * [3.6.2.1 弱引用][100]
            * [3.6.2.2 软引用][101]
            * [3.6.2.3 虚引用][102]
        * [3.6.3 JVM的行为差异][103]
    * [3.7 陷阱与伪优化][104]
        * [3.7.1 Java不是C++][105]
    * [3.8 JRockit中的内存管理][106]
        * [3.8.1 基本参数][107]
           * [3.8.1.1 打印垃圾回收日志][108]
           * [3.8.1.2 设置堆的初始值和最大值][109]
           * [3.8.1.3 设置垃圾回收器的执行目标][110]
           * [3.8.1.4 指定垃圾回收策略][111]
        * [3.8.2 压缩引用][112]
        * [3.8.3 高级选项][113]
    * [3.9 小结][114]
* [4 线程与同步][115]
    * [4.1 基本概念][116]
        * [4.1.1 难以调试][117]
        * [4.1.2 难以优化][118]
            * [4.1.2.1 延迟性分析][119]
    * [4.2 Java API][120]
        * [4.2.1 synchromized关键字][121]
        * [4.2.2 java.lang.Thread类][122]
        * [4.2.3 java.util.concurrent包][123]
        * [4.2.4 信号量][124]
        * [4.2.5 volatile关键字][125]
    * [4.3 Java中线程与同步机制的实现][126]
        * [4.3.1 Java内存模型][127]
            * [4.3.1.1 早期内存模型中的问题][128]
            * [4.3.1.2 JSR-133][129]
        * [4.3.2 同步的实现][130]
            * [4.3.2.1 原生机制][131]
            * [4.3.2.2 锁(Lock)][132]
        * [4.3.3 同步在字节码中的实现][133]
            * [4.3.3.1 匹配的锁操作][134]
        * [4.3.4 线程的实现][135]
            * [4.3.4.1 绿色线程（green thread）][136]
            * [4.3.4.2 操作系统线程][137]
    * [4.4 对于线程与同步的优化][138]
        * [4.4.1 锁膨胀与锁收缩][139]
        * [4.4.2 递归锁][140]
        * [4.4.3 锁融合][141]
        * [4.4.4 延迟解锁][142]
            * [4.4.4.1 实现][143]
            * [4.4.4.2 禁用对象][144]
            * [4.4.4.3 禁用类][145]
            * [4.4.4.4 结论][146]
    * [4.5 陷阱与伪优化][147]
        * [4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`][148]
        * [4.5.2 双检查锁][149]
    *[4.6 相关命令行参数][150]
        * [4.6.1 检查锁与延迟解锁][151]
            * [4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为][152]
            * [4.6.1.2 使用参数`-XX:UseLazyUnlocking`][153]
        * [4.6.2 输出调用栈信息][154]
        * [4.6.3 锁分析][155]
            * [4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析][156]
        * [4.6.4 设置线程栈的大小][157]
        * [4.6.5 使用命令行参数控制锁的行为][158]
    * [4.7 小结][159]




[1]:    ./chap1/1.md#1                    "1 起步"
[2]:    ./chap1/1.1.md#1.1                "1.1 获得JRockit JVM"
[3]:    ./chap1/1.2.md#1.2                "1.2 将应用程序迁移到JRockit"
[4]:    ./chap1/1.2.md#1.2.1              "1.2.1 命令行选项"
[5]:    ./chap1/1.2.md#1.2.1.1            "1.2.1.1 系统属性"
[6]:    ./chap1/1.2.md#1.2.1.2            "1.2.1.2 标准命令行选项"
[7]:    ./chap1/1.2.md#1.2.1.3            "1.2.1.3 非标准命令行选项"
[8]:    ./chap1/1.2.md#1.2.2              "1.2.2 行为差异"
[9]:    ./chap1/1.3.md#1.3                "1.3 JRockit版本号的命名规则"
[10]:   ./chap1/1.4.md#1.4                "1.4 获取帮助"
[11]:   ./chap1/1.5.md#1.5                "1.5 小结"
[12]:   ./chap2/2.md#2                    "2 自适应代码生成"
[13]:   ./chap2/2.1.md#2.1                "2.1 平台独立性"
[14]:   ./chap2/2.2.md#2.2                "2.2 Java虚拟机"
[15]:   ./chap2/2.2.md#2.2.1              "2.2.1 基于栈的虚拟机"
[16]:   ./chap2/2.2.md#2.2.2              "2.2.2 字节码格式"
[17]:   ./chap2/2.2.md#2.2.2.1            "2.2.2.1 操作与操作数"
[18]:   ./chap2/2.2.md#2.2.2.2            "2.2.2.2 常量池"
[19]:   ./chap2/2.3.md#2.3                "2.3 代码生成策略"
[20]:   ./chap2/2.3.md#2.3.1              "2.3.1 纯解释执行"
[21]:   ./chap2/2.3.md#2.3.2              "2.3.2 静态编译"
[22]:   ./chap2/2.3.md#2.3.3              "2.3.3 完全静态编译"
[23]:   ./chap2/2.3.md#2.3.4              "2.3.4 混合模式"
[24]:   ./chap2/2.4.md#2.4                "2.4 自适应代码生成"
[25]:   ./chap2/2.4.md#2.4.1              "2.4.1 判断热方法"
[26]:   ./chap2/2.4.md#2.4.1.1            "2.4.1.1 调用计数器"
[27]:   ./chap2/2.4.md#2.4.1.2            "2.4.1.2 基于软件的线程采样"
[28]:   ./chap2/2.4.md#2.4.1.3            "2.4.1.3 硬件采样"
[29]:   ./chap2/2.4.md#2.4.2              "2.4.2 优化动态程序"
[30]:   ./chap2/2.5.md#2.5                "2.5 深入JIT编译器"
[31]:   ./chap2/2.5.md#2.5.1              "2.5.1 处理字节码"
[32]:   ./chap2/2.5.md#2.5.1.1            "2.5.1.1 字节码混淆"
[33]:   ./chap2/2.5.md#2.5.2              "2.5.2 字节码“优化器”"
[34]:   ./chap2/2.5.md#2.5.2.1            "2.5.2.1 抽象语法树"
[35]:   ./chap2/2.5.md#2.5.3              "2.5.3 优化字节码"
[36]:   ./chap2/2.6.md#2.6                "2.6 代码流水线"
[37]:   ./chap2/2.6.md#2.6.1              "2.6.1 为什么JRockit没有字节码解释器"
[38]:   ./chap2/2.6.md#2.6.2              "2.6.2 启动"
[39]:   ./chap2/2.6.md#2.6.3              "2.6.3 运行时代码生成"
[40]:   ./chap2/2.6.md#2.6.3.1            "2.6.3.1 Trampolines"
[41]:   ./chap2/2.6.md#2.6.3.2            "2.6.3.2 代码生成请求"
[42]:   ./chap2/2.6.md#2.6.3.3            "2.6.3.3 代码优化请求"
[43]:   ./chap2/2.6.md#2.6.3.4            "2.6.3.4 栈上替换"
[44]:   ./chap2/2.6.md#2.6.3.5            "2.6.3.5 簿记"
[45]:   ./chap2/2.6.md#2.6.4              "2.6.4 代码生成概述"
[46]:   ./chap2/2.6.md#2.6.4.1            "2.6.4.1 代码的中间表示"
[47]:   ./chap2/2.6.md#2.6.4.2            "2.6.4.2 JIT编译"
[48]:   ./chap2/2.6.md#2.6.4.3            "2.6.4.3 代码优化"
[49]:   ./chap2/2.7.md#2.7                "2.7 控制代码生成"
[50]:   ./chap2/2.7.md#2.7.1              "2.7.1 命令行选项与指导文件"
[51]:   ./chap2/2.7.md#2.7.1.1            "2.7.1.1 命令行选项"
[52]:   ./chap2/2.7.md#2.7.1.2            "2.7.1.2 指导文件"
[53]:   ./chap2/2.8.md#2.8                "2.8 小结"
[54]:   ./chap3/3.md#3                    "3 自适应内存管理"
[55]:   ./chap3/3.1.md#3.1                "3.1 自动内存管理相关概念"
[56]:   ./chap3/3.1.md#3.1.1              "3.1.1 自适应内存管理"
[57]:   ./chap3/3.1.md#3.1.2              "3.1.2 自适应内存管理的优点"
[58]:   ./chap3/3.1.md#3.1.3              "3.1.3 自适应内存管理的缺点"
[59]:   ./chap3/3.2.md#3.2                "3.2 堆管理基础"
[60]:   ./chap3/3.2.md#3.2.1              "3.2.1 对象的分配于释放"
[61]:   ./chap3/3.2.md#3.2.2              "3.2.2 碎片与整理"
[62]:   ./chap3/3.3.md#3.3                "3.3 垃圾回收算法"
[63]:   ./chap3/3.3.md#3.3.1              "3.3.1 引用计数"
[64]:   ./chap3/3.3.md#3.3.2              "3.3.2 引用跟踪"
[65]:   ./chap3/3.3.md#3.3.2.1            "3.3.2.1 标记-清理"
[66]:   ./chap3/3.3.md#3.3.2.2            "3.3.2.2 暂停-拷贝"
[67]:   ./chap3/3.3.md#3.3.3              "3.3.3 STW(stop-the-world)"
[68]:   ./chap3/3.3.md#3.3.3.1            "3.3.3.1 保守式 vs. 准确式"
[69]:   ./chap3/3.3.md#3.3.3.2            "3.3.3.2 livemap"
[70]:   ./chap3/3.3.md#3.3.4              "3.3.4 分代垃圾回收"
[71]:   ./chap3/3.3.md#3.3.4.1            "3.3.4.1 多个新生代的内存排布"
[72]:   ./chap3/3.3.md#3.3.4.2            "3.3.4.2 写屏障"
[73]:   ./chap3/3.3.md#3.3.5              "3.3.5 吞吐量 vs. 延迟"
[74]:   ./chap3/3.3.md#3.3.5.1            "3.3.5.1 优化吞吐量"
[75]:   ./chap3/3.3.md#3.3.5.2            "3.3.5.2 优化延迟"
[76]:   ./chap3/3.3.md#3.3.6              "3.3.6 JRockit中的垃圾回收"
[77]:   ./chap3/3.3.md#3.3.6.1            "3.3.6.1 老年代垃圾回收"
[78]:   ./chap3/3.3.md#3.3.6.2            "3.3.6.2 新生代垃圾回收"
[79]:   ./chap3/3.3.md#3.3.6.3            "3.3.6.3 永生代垃圾回收"
[80]:   ./chap3/3.3.md#3.3.6.4            "3.3.6.4 内存整理"
[81]:   ./chap3/3.4.md#3.4                "3.4 性能与伸缩性"
[82]:   ./chap3/3.4.md#3.4.1              "3.4.1 线程局部分配"
[83]:   ./chap3/3.4.md#3.4.2              "3.4.2 更大的堆内存"
[84]:   ./chap3/3.4.md#3.4.2.1            "3.4.2.1 32位架构下的4GB内存限制"
[85]:   ./chap3/3.4.md#3.4.2.2            "3.4.2.2 64位架构"
[86]:   ./chap3/3.4.md#3.4.3              "3.4.3 缓存友好性"
[87]:   ./chap3/3.4.md#3.4.3.1            "3.4.3.1 预抓取"
[88]:   ./chap3/3.4.md#3.4.3.2            "3.4.3.2 数据存放"
[89]:   ./chap3/3.4.md#3.4.4              "3.4.4 NUMA"
[90]:   ./chap3/3.4.md#3.4.5              "3.4.5 大内存页（Large pages）"
[91]:   ./chap3/3.4.md#3.4.6              "3.4.6 自适应（Adaptability）"
[92]:   ./chap3/3.5.md#3.5                "3.5 近实时垃圾回收"
[93]:   ./chap3/3.5.md#3.5.1              "3.5.1 软实时与硬实时"
[94]:   ./chap3/3.5.md#3.5.2              "3.5.2 JRockit Real Time"
[95]:   ./chap3/3.5.md#3.5.2.1            "3.5.2.1 软实时有效么？"
[96]:   ./chap3/3.5.md#3.5.2.2            "3.5.2.2 工作原理"
[97]:   ./chap3/3.6.md#3.6                "3.6 内存操作相关的API"
[98]:   ./chap3/3.6.md#3.6.1              "3.6.1 析构函数"
[99]:   ./chap3/3.6.md#3.6.2              "3.6.2 Java中的引用"
[100]:  ./chap3/3.6.md#3.6.2.1            "3.6.2.1 弱引用"
[101]:  ./chap3/3.6.md#3.6.2.2            "3.6.2.2 软引用"
[102]:  ./chap3/3.6.md#3.6.2.3            "3.6.2.3 虚引用"
[103]:  ./chap3/3.6.md#3.6.3              "3.6.3 JVM的行为差异"
[104]:  ./chap3/3.7.md#3.7                "3.7 陷阱与伪优化"
[105]:  ./chap3/3.7.md#3.7.1              "3.7.1 Java不是C++"
[106]:  ./chap3/3.8.md#3.8                "3.8 JRockit中的内存管理"
[107]:  ./chap3/3.8.md#3.8.1              "3.8.1 基本参数"
[108]:  ./chap3/3.8.md#3.8.1.1            "3.8.1.1 打印垃圾回收日志"
[109]:  ./chap3/3.8.md#3.8.1.2            "3.8.1.2 设置堆的初始值和最大值"
[110]:  ./chap3/3.8.md#3.8.1.3            "3.8.1.3 设置垃圾回收器的执行目标"
[111]:  ./chap3/3.8.md#3.8.1.4            "3.8.1.4 指定垃圾回收策略"
[112]:  ./chap3/3.8.md#3.8.2              "3.8.2 压缩引用"
[113]:  ./chap3/3.8.md#3.8.3              "3.8.3 高级选项"
[114]:  ./chap3/3.9.md#3.9                "3.9 小结"
[115]:  ./chap4/4.md#4                    "4 线程与同步"
[116]:  ./chap4/4.1.md#4.1                "4.1 基本概念"
[117]:  ./cgap4/4.1.md#4.1.1              "4.1.1 难以调试"
[118]:  ./chap4/4.1.md#4.1.2              "4.1.2 难以优化"
[119]:  ./chap4/4.1.md#4.1.2.1            "4.1.2.1 延迟分析"
[120]:  ./chap4/4.2.md#4.2                "4.2 Java API"
[121]:  ./chap4/4.2.md#4.2.1              "4.2.1 synchronized关键字"
[122]:  ./chap4/4.2.md#4.2.2              "4.2.2 java.lang.Thread类"
[123]:  ./chap4/4.2.md#4.2.3              "4.2.3 java.util.concurrent包"
[124]:  ./chap4/4.2.md#4.2.4              "4.2.4 信号量"
[125]:  ./chap4/4.2.md#4.2.5              "4.2.5 volatile关键字"
[126]:  ./chap4/4.3.md#4.3                "4.3 Java中线程与同步机制的实现"
[127]:  ./chap4/4.3.md#4.3.1              "4.3.1 Java内存模型"
[128]:  ./chap4/4.3.md#4.3.1.1            "4.3.1.1 早期内存模型中的问题"
[129]:  ./chap4/4.3.md#4.3.1.2            "4.3.1.2 JSR-133"
[130]:  ./chap4/4.3.md#4.3.2              "4.3.2 同步的实现"
[131]:  ./chap4/4.3.md#4.3.2.1            "4.3.2.1 原生机制"
[132]:  ./chap4/4.3.md#4.3.2.2            "4.3.2.2 锁(Lock)"
[133]:  ./chap4/4.3.md#4.3.3              "4.3.3 同步在字节码中的实现"
[134]:  ./chap4/4.3.md#4.3.3.1            "4.3.3.1 匹配的锁操作"
[135]:  ./chap4/4.3.md#4.3.4              "4.3.4 线程的实现"
[136]:  ./chap4/4.3.md#4.3.4.1            "4.3.4.1 绿色线程（green thread）"
[137]:  ./chap4/4.3.md#4.3.4.2            "4.3.4.2 操作系统线程"
[138]:  ./chap4/4.4.md#4.4                "4.4 对于线程与同步的优化"
[139]:  ./chap4/4.4.md#4.4.1              "4.4.1 锁膨胀与锁收缩"
[140]:  ./chap4/4.4.md#4.4.2              "4.4.2 递归锁"
[141]:  ./chap4/4.4.md#4.4.3              "4.4.3 锁融合"
[142]:  ./chap4/4.4.md#4.4.4              "4.4.4 延迟解锁"
[143]:  ./chap4/4.4.md#4.4.4.1            "4.4.4.1 实现"
[144]:  ./chap4/4.4.md#4.4.4.2            "4.4.4.2 禁用对象"
[145]:  ./chap4/4.4.md#4.4.4.3            "4.4.4.3 禁用类"
[146]:  ./chap4/4.4.md#4.4.4.4            "4.4.4.4 结论"
[147]:  ./chap4/4.5.md#4.5                "4.5 陷阱与伪优化"
[148]:  ./chap4/4.5.md#4.5.1              "4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`"
[149]:  ./chap4/4.5.md#4.5.2              "4.5.2 双检查锁"
[150]:  ./chap4/4.6.md#4.6                "4.6 相关命令行参数"
[151]:  ./chap4/4.6.md#4.6.1              "4.6.1 检查锁与延迟解锁"
[152]:  ./chap4/4.6.md#4.6.1.1            "4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为"
[153]:  ./chap4/4.6.md#4.6.1.2            "4.6.1.2 使用参数`-XX:UseLazyUnlocking`"
[154]:  ./chap4/4.6.md#4.6.2              "4.6.2 输出调用栈信息"
[155]:  ./chap4/4.6.md#4.6.3              "4.6.3 锁分析"
[156]:  ./chap4/4.6.md#4.6.3.1            "4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析"
[157]:  ./chap4/4.6.md#4.6.4              "4.6.4 设置线程栈的大小"
[158]:  ./chap4/4.6.md#4.6.5              "4.6.5 使用命令行参数控制锁的行为"
[159]:  ./chap4/4.7.md#4.7                "4.7 小结"