<a name="13.3" />
# 13.3 虚拟化能媲美真实环境吗？

移除不必要的中间虚拟层只是性能优化的第一步，如果能控制操作系统层，使JVM知道该如何与其进行通信的话，就能使JVM获得更多重要信息，进而极大的扩展自适应运行时的能力。

>这一节的内容更趋向于推测，其中所设计到的技术在将来可能会发生变化，但不出意外的话，它们应该就是高性能虚拟化的基础。

<a name="13.3.1" />
# 13.3.1 高质量的热点代码采样

提高热点代码采样信息的质量可以提升系统的整体性能。在[第2章][1]中曾介绍过，采样信息越详细，代码优化的质量就越高。当在系统中运行调度器来控制所有的线程时，采样的开销会急剧增大。要想查找Java指令寄存器的内容，无需调用开销巨大的操作系统调用（改变 **RING**级别）来暂停所有的应用程序线程，通过JVM内部实现的绿色线程（参见[第4章][2]内容）就可以实现。启动/终止绿色线程的开销极小，跟操作系统线程相比完全不是一个数量级。JRockit VE中的线程实现与绿色线程颇有相似之处。

JRockit VE中的采样质量堪比基于硬件的采样（参见[第2章][1]），使JVM能够获得更多的运行时信息，为指定优化策略提供数据支持，提升决策的准确性。

<a name="13.3.2" />
# 13.3.2 自适应堆大小

除了采样信息之外，另一个性能提升点在于启用堆大小的自适应调整。

大多数虚拟机管理程序都支持名为 **膨胀（ballooning）**的技术，该技术使虚拟机管理程序和客户应用程序可以就内存的使用情况进行协商，而无需破坏各个客户应用程序之间的沙箱模型。就具体实现来说，就是实现一个膨胀驱动程序（balloon driver）的中间层，为客户应用程序提供一个伪虚拟设备，虚拟机管理程序通过该伪虚拟设备提示客户应用程序需要扩大内存。当内存不足，需要回收一些其他客户应用程序占用的内存时，客户应用程序可以通过膨胀驱动程序解析出出由虚拟机管理程序发出的有关"扩大内存"的提示。

此外，膨胀还可以实现内存的超量使用，例如使各个客户应用程序占用的总内存可以超过物理内存的总量。鉴于该技术可用于实现无换页操作，因此可说是非常强大的技术。

由于JVM中Java堆所占用的内存总量比JRockit VE内核所占用的本地内存总量大上几个数量级，因此对于虚拟机管理程序来说，回收内存最有效的方式就是对Java堆做伸缩处理。如果虚拟机管理程序通过膨胀驱动程序报告内存压力过大，则JVM应该通过外部API（所谓"外部"，是指JRockit VE内核暴露给JVM的接口）来收缩Java堆，这个调用可能会触发Java堆的内存整理操作。

另一方面，如果垃圾回收的执行时间过长，则JVM应该询问JRockit VE内核是否需要通过虚拟机管理程序回收一些内存。这个询问操作只存在于JRockit和JRockit VE平台，是作为JRockit VE平台抽象层供JVM使用的。

传统的操作系统并不支持"提示进程需要释放/增加内存"的操作，对于自适应内存管理来说，这完全可以再开一章单独详述了。因此，JRockit VE可以保证JVM可以恰到好处的使用内存，及时释放内存供其它客户应用程序使用，避免因换页操作（内存不足时可能需要执行换页操作）而带来的性能开销（这开销很大）。这个特性使JRockit VE非常适合作为虚拟环境来运行Java应用程序，可以及时调整各个客户应用程序的运行配置，最大化资源利用率。

<a name="13.3.3" />
# 13.3.3 线程间的页保护

移除JVM和硬件之间的操作系统层可能会带来意想不到的大收益。

回想一下标准操作系统中进程和线程的概念，就定义来说，同一进程中的线程会共享虚拟内存，而且并没有内置的内存保护机制来保护线程对内存的并发访问，但不同进程则肯定不能访问对方的内存数据。现在假设每个线程都可以保留一部分其他线程无法访问的内存（当然，其他进程的线程就更不能了）。如果某个线程试图访问另一个线程私有内存区域，则可能会产生一个页错误（page fault）。这种机制与标准操作系统中的页保护相类似，只不过控制粒度更精细，实现这个机制并不复杂，JRockit VE就是通过改变线程的定义来实现的。

对于标准操作系统来说，要想在JVM实现这种快速、透明的线程内页保护机制是不可能的，但对于像JRockit VE内核这样的"操作系统"来说，那就小菜一碟了。Oracle已经就这种技术申请了多项专利。

[13.3.3.1节][3]和[13.3.3.2节][4]的内容阐述了这这项技术强大的威力。








[1]:    ../chap2/2.md#2
[2]:    ../chap4/4.md#4
[3]:    #13.3.3.1
[4]:    #13.3.3.2