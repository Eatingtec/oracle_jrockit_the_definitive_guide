<a name="13.2" />
# 13.2 Java虚拟化

接下来讨论一下在生产环境中通过虚拟环境运行Java应用程序的事情。下面的示意图展示展示了从应用程序服务器到物理硬件之间的所有结构。在Java应用程序和物理硬件之间，包含了JVM，操作系统（例如Oracle Enterprise Linux）和虚拟机管理程序（如Oracle VM）。

![Figure 13-1][1]

像Oracle WebLogic这样的应用服务器就是通过JVM来与你行的。JVM为运行在其上的Java应用程序提供了针对各类操作系统的抽象，屏蔽操作系统之间的差异，实现"一次编写，到处运行"。

位于在JVM之下的是底层操作系统，JVM需要与之一一适配，例如，在类Unix系统上，内存的分与机制与Windows系统颇为不同，系统调用也有所区别（`mmap` vs. `VirtualAlloc`）。为了实现"一次编写到处运行"，JVM需要应用具体的操作系统模块来操作内存，因而，操作系统就充当了JVM和机器之间的抽象层。

因此，通用操作系统的作用就是对硬件进行抽象，以便简化应用程序与硬件的交互。让应用程序的开发人员通过原子汇编指令自行实现针对特定芯片的同步机制或线程实现，是不现实的，而操作系统就是为完成这些任务而生的，是JVM下的第2层抽象。

最后，在虚拟世界中，虚拟机管理程序形成了第3层抽象，各个客户应用程序均通过虚拟机管理程序来访问物理硬件。

抽象层之间的交互也会带来一些性能损耗，高层抽象与低层抽象进行交互时往往会涉及到一些特权操作，例如获取时间、清除缓存，以及抢占任务等。

如果虚拟操作系统的唯一任务是运行JVM的话，而JVM的唯一任务就是运行Java应用程序的话，那为啥还要弄出来这么多层呢，不是很浪费吗？只为运行一个Java应用程序需要这么麻烦么？事实上，Java应用程序（假设是纯Java代码编写的应用程序）并不知道它运行在什么系统上，也不关心这些。如果Java应用程序不涉及到GUI，还需要在显示功能么？如果所有的访问控制都由应用程序内部处理，那还需要操作系统么？

JVM需要提供JDK库函数以支持线程和同步，实现内存管理，以及其他林林总总的任务。因此，不太严谨的说，JVM就是一个专用的虚拟操作系统。

或许让JVM直接跑在虚拟机管理程序上是个不错的主意。

<a name="13.2.1" />
# 13.2.1 JRockit Virtual Edition

如果能在保留Java虚拟化优势的情况下，去除虚拟化的开销，那肯定是好处多多。如果Java和硬件之间的抽象层能足够小，则不仅可以提升性能，还能简化系统，增强安全性。对此，JRockit架构提出的解决方案是JRockit VE（JRockit Virtual Edition）。

>在2005年的时候，俺们写了个链接器来查找丢失了哪些JVM所生成的符号，结果发现，没少几个，而这就成了JRockit VE项目的雏形。

JRockit VE包含JRockit JRE，纯Java服务（例如SSH守护进程），以及一个迷你操作系统（即所谓的JRockit VE内核），通过该迷你操作系统，使JVM看来像是运行在虚拟机管理程序顶层一样，并为JVM提供所需的操作系统功能（当然，只提供了很有限的一部分功能）。

目前，JRockit VE还只支持x86平台。

>目前，JRockit VE的商业版只能运行在Oracle VM的虚拟机管理程序上（也就是运行在Xen上），将来或许会支持其他虚拟机管理程序。
>
>JRockit VE的设计哲学是，JRockit VE内核的运行平台是硬件，而不是虚拟机管理程序。因此，JRockit VE内核中包含了一个小型的E1000网卡驱动，可以在任何x86平台上，通过USB启动JRockit VE来运行Java应用程序。这个例子确实很酷，或许不太能说明JRockit VE对云计算的贡献，不过俺们会继续努力的。

JRockit VE中还提供了相关工具（即Image Tool）来创建/操作用于运行在虚拟环境中的Java应用程序。当虚拟化一个JRockit VE中的Java应用程序时，实际上指的是操作一个 **虚拟机镜像**。

![Figure 13-2][2]

上图展示了部署在JRockit VE上的Java应用程序的软件栈。部署时，像SSH这类的服务是在Java层运行的。JRockit JVM位于JRockit VE内核顶部，为JRockit JVM提供底层支持。

接下来，将会对JRockit VE内核的相关功能和实现细节做详细介绍。

<a name="13.2.1.1" />
### 13.2.1.1 JRockit VE内核

JRockit VE移除了JVM对底层操作系统以来，尽量使Java直接运行在虚拟机管理程序上。目前，Linux版本的JRockit JVM可以直接运行在JRockit VE内核上。不过，在后续的版本中，可能会将JRockit VE内核整合为完整的JVM平台，这样可以减少软件栈中抽象层的数量，简化具体实现。之所以现在通过JRockit VE内核来模拟Linux API是因为实在是没时间来为JRockit JVM开发专用的平台。

>虽说现在JRockit JVM只是个Linux发行版，不过却不会对性能产生额外影响，也不会将JRockit JVM绑死到Linux上。通过操作系统层，JRockit VE内核可以为Linux版本的JVM提供更为理想的执行环境。通过专用的JVM，可以进一步提升应用程序的整体性能。

从概念上讲，JRockit VE内核与操作系统非常相像，但真作为操作系统用的话还差得很远。它虽然包含了线程实现、调度器、文件系统、内存分配等模块，但和真正的操作系统相比，还太简单。

JRockit VE内核只能运行一个进程，即JRockit JVM。此外，由于JVM是一个沙箱，因此也不必担心恶意的Java代码会对系统造成危害，而且JVM本身也会进行相关的安全审查（例如字节码校验）。

不过，这里有一个重要限制，即JRockit VE会禁用任何本地代码，因为确实没办法确认本地代码到底要干啥。这既是功能性问题，也是安全性问题。本地代码中可能会包含有系统调用，而这可能是平台相关的，而且本地代码中可能还会含有恶意代码。就目前的Java应用程序来看，禁用本地代码还不算是个太大的问题，因此JRockit VE也就不支持JNI了。

JRockit VE内核的另一个限制就是不具备常见于通用操作系统的高级分页机制。因为JRockit VE只会运行JRockit JVM一个进程，所以只映射一个虚拟地址空间就够了。

下图展示了JRockit VE内核中的各个模块，包括文件系统、设备驱动（用于与虚拟机管理程序进行通信）、块缓存、自包含的网络栈、内存管理和线程调度器等等。

![Figure 13-3][3]

JRockit VE内核的API与类Unix系统非常相似。正如前文提到的，Linux版本的JRockit JVM可以直接运行在JRockit VE内核上，不过这只说明JRockit VE内核实现了通常操作系统的部分功能，并不意味着JRockit VE内核真的兼容了Linux系统。通常来说，JVM主要使用POSIX系统调用，因此，即便以后运行JRockit时需要感知到JRockit VE的存在，也可以省去很多"伪装"成Linux系统所带来的麻烦。例如，无需在内核中模拟`/proc`文件系统，因为JRockit在Linux上就是通过POSIX调用来获取内存信息的。此外，还可以移除一些操作系统调用，例如`mmap`，它看起来像是JRockit VE中的POSIX调用，但实际上却不是。在标准的POSIX调用中，`mmap`非常复杂，但在JRockit VE中，只是为了"伪装"成Linux而特意实现的。通过这种"伪装"，在将JRockit移植到JRockit VE上时，就不需要做太复杂的修改了。

在学习JRockit VE内核时，千万不要被它带偏了，虽然它看起来像个轻量级操作系统，但实际上绝不是操作系统，很多操作系统必需的复杂机制都被舍弃了。对于像Linux这样的来说，设备驱动程序的复杂性远大于内核本身，而对于运行在虚拟机管理程序上的JRockit VE来说，这完全没必要，因为虚拟机管理程序会处理好和硬件设备的通信。JRockit VE内核模块本身只有大约13万行C语言代码，而其中大部分都是网络栈相关的代码。














[1]:    ../images/13-1.jpg
[2]:    ../images/13-2.jpg
[3]:    ../images/13-3.jpg