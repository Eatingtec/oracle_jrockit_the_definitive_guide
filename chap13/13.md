<a anme="13" />
# 13 JRockit Virtual Edition

近些年，**虚拟化（virtualization，即在模拟硬件上运行软件）**，可谓是风头正劲。通过虚拟化可以最大化硬件资源利用率，同时可以简化资源管理。不过，作为应用程序和实际硬件中间的抽象层，虚拟化会带来额外的性能损耗。

本章将会对JRockit Virtual Edtion及其相关技术进行介绍。在本章中，会以JRockit VE作为JRockit Vritual Edtion的简称使用。

JRockit VE使用户可以在一个没有操作系统的虚拟环境中运行Java应用程序，同时免去了虚拟化所带来的大量性能损耗。JRockit VE是一款独立的产品，包含了运行Java应用程序所需要的最小环境，即一个轻量级的类OS内核和一个JRockit JRE。

JRockit VE可以运行任何Java应用程序，不过最初可能更多的是作为 **WLS on JRockit VE（WebLogic Server on JRockit Virtual Edtion）**产品的一部分来使用。WLS on JRockit VE是以虚拟机镜像（virtual machine image）格式预先打包好的WebLogic Server安装文件。虚拟机镜像是一个二进制镜像，其中包含了虚拟机配置，二进制软件和文件系统，将虚拟机镜像部署在专门的虚拟环境（例如Oracle VM Server）中，就可以运行相应的应用程序。

作为对JRockit VE相关技术的介绍，本章会着重讲解虚拟化JRockit VE背后的相关技术。对于构建与JRockit VE之上的软件栈，则不再赘述。

>本章旨在介绍新近技术产品，因此在细节、名称和具体实现上可能会因与目前所见到的有所区别，而且在本章中还有一些前瞻性的、还未实现的技术介绍。万变不离其宗，不论如何，核心概念上是相同的。相关产品的最新信息可以在官网的在线文档上查看。

本章主要包含以下内容：

* 虚拟化的基本概念以及几种不同的虚拟化实现的相关介绍
* Hypervisor相关介绍
* 软件栈虚拟化的优劣
* Java虚拟化的相关问题，以及JRockit VE简化虚拟化进程并提升性能的方法
* 虚拟机镜像相关概念
* 虚拟化的未来

<a name="13.1" />
# 13.1 虚拟化简介

近些年，虚拟化逐渐成为了热点话题，但它其实仍旧是将硬件资源抽象为一个虚拟层，这本身并不是什么新鲜事物。现在所有的操作系统中标配的虚拟内存就是一种虚拟化，单一物理硬盘划分为多个分区也是一种虚拟化。相比之下，最近热炒的虚拟化更多的是指虚拟整个物理机，不过这也不是什么新玩意，早在1960年代IBM就已经开始做相关的产品了。但直到最近，才真正充分发挥了虚拟化的威力，既增加了资源利用率，又提升了整体的管理能力。

虚拟化是以软件模拟运行平台（如操作系统）或在虚拟硬件上运行独立的应用程序。想你硬件通常与实际运行的物理硬件类似，部署在虚拟系统上的应用程序套件通常称为 **客户应用程序（guest）**，而被称为 **虚拟机管理程序（hypervisor）**的软件栈则可以使多个客户应用程序运行在同一个系统上。虚拟机管理程序可以为客户应用程序提供设备驱动程序，使其可以运行在虚拟环境中，进而提升 客户应用程序的运行性能。

>不同类型的虚拟化资源在其具体是线上有所不同。例如，看起来像是物理硬盘的资源，实际上只是某处服务器上的一个或一组文件；看起来像是有4个物理CPU可用，实际上可能只是几个CPU分时共享而已；看起来有1GB物理内存可用，实际上可能只是大容量物理内存的一部分。某些虚拟化管理程序甚至允许客户应用程序分配出的内存容量超过其分配限额。不过对于客户应用程序来说这无所谓，它仍旧只能看到其分配限额的内存（当然也有例外）。

虚拟化愈炒愈热，主要原因在于虚拟化可以更高效的利用已有的硬件资源。如果物理机上的CPU处于空闲状态（例如可能是在等待IO），那么就真的是只能闲置了。而对于那些运行了多个客户应用程序的虚拟环境来说，若某个客户应用程序的CPU处于空闲状态，则可以将CPU资源交给其他客户应用程序使用。当然，若是多个客户应用程序都特别"忙"，则反而会因频繁的上下文切换而降低执行性能。不过虚拟化的优势实在诱人，它大大提升了硬件资源的利用率，在环境问题日益严重的今天，合理利用资源才能更好的利用能源。

虚拟化可以划分为多种类型，划分的主要依据是其背后所代表的平台层级。这其中所涉及到一些常被混淆的技术概念，接下来内容中会对其做简单介绍。虚拟化本身很复杂，却可以简化开发和运维。

<a name="13.1.1" />
## 13.1.1 全虚拟化

**全虚拟化（full virtualization）**是指，虚拟机管理程序模拟出当前系统平台所能提供的所有关键功能，例如设备交互和内存映射。这样，作为客户应用程序的应用软件就可以不经修改直接部署上线。

对于那些硬件不能直接支持虚拟化的平台来说，可以通过捕获客户应用程序执行的特权指令来模拟沙箱环境供其使用。

若是有硬件支持（例如Intel VT或AMD-V技术可以是CPU同时运行在多个操作系统上），实现虚拟化就更加方便了。有了硬件的直接支持，虚拟化将更有效率，性能更好。最近，出了CPU之外，其他硬件出现了直接支持虚拟化的趋势，例如现在某些网卡就内建了对虚拟化的直接支持。

有了硬件的直接支持后，虚拟化性能大幅提升，因而全虚拟化的发展突飞猛进。

<a name="13.1.2" />
## 13.1.2 半虚拟化

**半虚拟化（paravirtualization）**是指客户应用程序在运行时需要知晓其运行在虚拟环境。典型场景是，客户应用程序在执行特权操作时，需要通过显式调用虚拟机管理程序的API接口来才能完成操作，即客户应用程序必须要与底层抽象层进行通信，因而就需要知道它自己是运行在虚拟环境中的。

半虚拟化牺牲了部分虚拟化的灵活性，因为在将客户应用程序（例如操作系统）部署到虚拟环境之前需要做相应的修改。相应的，半虚拟化可以舍弃那些不必要的抽象层，进而提升整个虚拟环境的运行性能，而且用户也不必关心底层虚拟机管理程序的具体实现。例如，早期的Xen是一个只支持半虚拟化的虚拟机管理程序，主要功能就是运行那些预先打包好的操作系统镜像，用户只需要将应用程序部署在这些打包好的操作系统镜像上即可。

硬件的直接支持使全虚拟化大踏步前进，相比之下，半虚拟化则已是明日黄花。

<a name="13.1.3" />
## 13.1.3 其他虚拟化术语

虚拟化领域还有很多专业术语，用于表述不同的含义，例如 **部分虚拟化（partial virtualization）**。在某些场景下，半虚拟化和部分虚拟化是同一个意思，此外，部分虚拟化还可以表示虚拟硬件的指定部分。例如，在Macintosh计算机上，部分虚拟化还用与描述像Rosetta这样的二进制转换工具（使用在PowerPC上编译的软件可以运行在Intel架构上。）。

部分虚拟化并不强求硬件支持，操作系统中的虚拟内存也可算作是部分虚拟化的一种。最近，操作系统级虚拟化颇受关注，典型场景就是将操作系统划分为可以同时运行的多个实例，看起来像是真的有多个操作系统一样。广为人知的Solaris Containers就是以这种技术实现的。