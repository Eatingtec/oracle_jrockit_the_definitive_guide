# 4.3 Java中线程与同步机制的实现

本节将对Java运行时中线程和同步机制的实现以及相关背景知识进行介绍，以便读者可以更好的处理并行结构，理解如何使用同步机制而不会造成较大的性能损耗。

<a name="4.3.1" />
## 4.3.1 Java内存模型

现在CPU架构中，普遍使用了数据缓存机制，可以大幅提升CPU对数据的读写速度，降低处理器总线的竞争程度。正如所有的缓存系统一样，这里也存在一致性问题，对于多处理器系统来说尤其重要，因为多个处理器有可能同时访问内存中同一位置的数据。

内存模型定义了不同的CPU在同时访问内存中同一位置是，何种情况下会看到相同的值，何种情况下会看到不同的值。强内存模型（例如x86平台上，就相当强）是指，当某个CPU修改了某个内存位置的值后，其他的CPU几乎自动就可以看到这个刚刚保存的值，在这种内存模型之下，内存写操作的执行顺序与代码中的排列顺序相同。弱内存模型（例如IA-64平台）是指，当某个CPU修改了某个内存位置的值后，其他的CPU不一定可以看到这个刚刚保存的值（除非CPU在执行写操作时附有特殊的内存屏障类指令），从更一般的角度说，所有由Java程序引起的内存访问都应该堆其他所有CPU可见，但事实上却不能保证一定立即可见。

不同硬件平台上对于"读-写" "写-读" "写-写"操作的处理有细微区别。Java为了屏蔽硬件区别，因此定义了JVM对这些操作的具体处理方式。对于像C++这样会编译为平台相关代码，而且缺少内存模型的的静态编程语言来说，在对操作读写时就会比较痛苦，需要仔细考虑不同平台之间的区别。尽管C++中也有`volatile`关键字，但应用程序的具体行为还无法独立于其所在的系统平台。此外，在C++中，部分"事实上的"内存模型并不属于编程语言自身，而是由线程库和操作系统调用决定的。在像Intel IA-64这种具有弱内粗模型的CPU架构上，程序员有时甚至会在代码中显式使用内存屏障。 总之，C++源代码在某个系统平台上完成编译，应用程序的行为也就不会再发生改变了。

Java是如何保证在所有支持的平台上具有相同的行为呢？在Java编程语言中并不存在内存屏障这东西，而且考虑到Java所追求的平台无关性，或许就不应该有内存屏障。
