<a name="10.4" />
# 10.4 追踪内存泄漏

排查内存泄漏问题是个技术活儿，通常会交叉使用多种工具和技术。有时候，应用程序会意外持有无用对象的引用，而且若被泄露的内存分别在不同的地方分配和持有，则排查起来就更加困难，因此需要详细分析才能找到内存泄漏的真正根源。

启动 **Memleak**只需在JRockit Mission Control的 **JVM Browser**视图中，右键点击目标JVM，选择 **Memleak**即可。

>同一时间，只能有一个Memleak连接到目标JVM上。

在Memleak中，**Trend Table**可用于检测是否有潜在的内存泄漏，其具体实现是通过定期构建应用程序中各类型对象实例数量的直方图，再经过对比判断来实现的。针对各类型实例所占用内存做最小二乘拟，并"字节/每秒"为单位显示内存增长率。

>在JRockit Mission Control 4.1.0版本中，该算法会相对复杂一点，它需要整合存活对象集的数量。若某些类型的实例的随存活对象集大小的增长曲线相匹配，则很可能是在这些类型上出现了内存泄漏。

**趋势表（Trend Table）**常用于查找内存泄漏的根源。在趋势表中，增长率很高的类均以红色显示，还可以显示出相关实例的数量和占用的内存。

从下面的截图中可以看出，很有可能是字符数组发生了内存泄漏。在截图中，字符数组以深红色表示，处于趋势表的顶部，增长率位居首位。

![Figure 9-41][1]

此外，`Leak$DemoObject`和`Hashtable`类型的示例也正发生内存泄漏，只不过严重程度稍低而已。

总体来看，内存泄漏的速率为7.5KB/s。

    (6.57*1,024+512+307+71+53+11)/1,024 ≈ 7.5

JVM堆的最大值为256MB，已使用的存活对象集为20MB（该数值可以在Management Console中查到）。

    (256 – 20) *1,024 / 7.5 ≈ 32,222 seconds ≈ 537 minutes ≈ 22 hours

照此下去，在22小时后，应用程序就会因`OutOfMemoryError`错误而崩溃。

嗯，还有一段时间可用来查找内存泄漏的根源。右键点击趋势表中的字符数组，选择 **Add to Type Graph**菜单，如下图所示：

![Figure 9-42][2]

这样，就会将字符数组类型加入到 **Type Graph**标签页，并自动切换到该标签页。**Type Graph**标签页中并不是显示类型的继承关系图，而是显示实例之间的引用关系图，并且只会显示被选中的类型的实例。如下图所示：

![Figure 9-43][3]

点击类型名左侧的绿色加号，会显示出有哪些类型包含指向该类型的引用。每次点击类型名左侧的加号都会扩展出其他几个节点，其中包括了泄漏内存最多的类型。

与趋势表类似，在 **Type Graph**中，增长过快的类型也以深红色进行表示

在这个示例中，若想找出到底是哪些对象引用了字符数组，则需要展开字符数组节点：

![Figure 9-44][4]

展开字符数组后，只有一种类型是疑似内存泄漏的，即`Leak`类的内部类`DemoObject`。

继续展开`Leak$DemoObject`类及其展开的子类型，直到发现应用程序可能在滥用`Hashtable`类，如下图所示：

![Figure 9-45][5]

接下来，需要找出到底是哪个`Hashtable`对象被误用了。这有多种实现方法。在本例中，由于基本确定了`Leak$DemoObject`发生了内存泄漏，因此只需要列出有哪些`Hashtable$Entry`类的实例指向`Leak$DemoObject`实例即可。

>Java中的内部类（例如`Hashtable`类中的`Entry`类）在字节码中是以`OuterClass$InnerClass`这种格式命名的，在分析工具中显示的就是这种字节码格式的类命名规范，在本例中是`Hashtable$Entry`和`Leak$DemoObject`。这是因为Sun公司在为Java语言引入内部类的时候，并不像修改JVM规范，因此就在类型名上做了调整。

要想列出具有特殊关联关系的实例，只需右键点击关联关系，选择 **List Referring Instances**菜单即可：

![Figure 9-46][6]

![Figure 9-47][7]

这样，就会在Memleak编辑器左侧打开实例视图，在其中列出指向`Leak$DemoObject`实例的`Hashtable$Entry`实例。右键点击其中某个实例，选择`Add to Instance Graph`菜单。这时会显示出一个类似于`Type Graph`的图像，只不过其内容是各个实例之间的引用关系。










[1]:    ../images/9-41.jpg
[2]:    ../images/9-42.jpg
[3]:    ../images/9-43.jpg
[4]:    ../images/9-44.jpg
[5]:    ../images/9-45.jpg
[6]:    ../images/9-46.jpg
[7]:    ../images/9-47.jpg