<a name="10.1" />
# 10.1 Java内存泄漏

应用程序中已经分配出去的内存不再使用后，就应该归还给系统。Java自身带有垃圾回收器，与C语言这类静态编程语言差别较大，使开发人员无需再显式的释放内存。但实际情况是，如果无用内存没有被归还给系统的话，仍然会产生内存泄漏，最终，使系统因内存不足而崩溃。

## 10.1.1 静态编程语言中的内存泄漏

在静态语言中，内存管理本身比释放内存更复杂一些，因为必须要确保释放内存的操作不会使应用程序崩溃。在没有自动内存管理的年代，这并不容易。假设有某个服务是用于获取地址记录的，处于效率考虑，地址记录都是放在内存中的。如果模块A，B和C都会使用该服务，则他们可能会并发的引用同一个地址记录。

If one of the modules decides to free the memory of the record once it is done, all the
other modules will fail and the program will crash. Consequently, we need a firm
allocation and deallocation discipline, possibly combined with some mechanism to let
the service know once every module is done with the address record. Until this is the
case, it cannot be explicitly freed. As has been previously discussed, one approach is
to manually implement some sort of reference counting in the record itself to ensure
that it can be reclaimed once all modules are finished with it. This may in turn require
synchronization and will add complexity to the program. To put it simply, sometimes,
in order to achieve proper memory hygiene in static languages, the programmer may
have to implement code that behaves almost like a garbage collector.

如果某个模块在完成工作后，就释放了地址记录所占用的内存，则其他正在使用该地址记录的模块就会操作失败，导致应用程序崩溃。因此，在分配/释放内存时，必须要有明确严格的规范，并且最好能使服务知晓某个模块已经完成针对某个地址记录的操作。就本例来说，各个模块是不可以显示释放地址记录的内存的。解决方法的话，是在地址记录上实现类似引用计数的结构，以保证在所有模块都完成操作后再释放内存。不过，这种方式需要用到同步锁，而且增加了系统的复杂性。